<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>mpvue开发小程序笔记——4.koa入门</title>
      <link href="/2018/06/07/mpvue%E5%BC%80%E5%8F%91%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%944.koa%E5%85%A5%E9%97%A8/"/>
      <url>/2018/06/07/mpvue%E5%BC%80%E5%8F%91%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%944.koa%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<p><strong>koa是什么？</strong><br>koa基于Nodejs平台的下一代web开发框架（上一代是express）。</p><ol><li>Express原班人马打造，更精简。</li><li>Async+await处理异步</li><li>洋葱圈型的中间件机制。<br>用法很简单：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir koa-demo</span><br><span class="line">npm init</span><br><span class="line">npm install koa --save</span><br></pre></td></tr></table></figure></li></ol><p>文件夹中新建一个server.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;)</span><br><span class="line">const app = new Koa()</span><br><span class="line"></span><br><span class="line">app.use(async(ctx, next) =&gt; &#123;ctx.body = &apos;hello&apos;&#125;)</span><br><span class="line">app.listen(3000)//端口3000</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node server.js</span><br></pre></td></tr></table></figure><p>就可以访问localhost:3000了。<br>ctx是什么呢？封装了request和response的上下文。<br>next是什么呢？下一个中间件。<br>app是什么呢？启动应用<br><strong>中间件机制：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;)</span><br><span class="line">const app = new Koa()</span><br><span class="line"></span><br><span class="line">app.use(async(ctx, next) =&gt; &#123;</span><br><span class="line">ctx.body = &apos;1&apos;</span><br><span class="line">next()</span><br><span class="line">ctx.body += &apos;2&apos;</span><br><span class="line">&#125;)</span><br><span class="line">app.use(async(ctx, next) =&gt; &#123;</span><br><span class="line">ctx.body += &apos;3&apos;</span><br><span class="line">next()</span><br><span class="line">ctx.body += &apos;4&apos;</span><br><span class="line">&#125;)</span><br><span class="line">app.use(async(ctx, next) =&gt; &#123;</span><br><span class="line">ctx.body += &apos;5&apos;</span><br><span class="line">next()</span><br><span class="line">ctx.body += &apos;6&apos;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(3000)</span><br></pre></td></tr></table></figure></p><p>结果是：135642<br>下面这个图可以解释这个机制。</p><p><img src="https://camo.githubusercontent.com/d80cf3b511ef4898bcde9a464de491fa15a50d06/68747470733a2f2f7261772e6769746875622e636f6d2f66656e676d6b322f6b6f612d67756964652f6d61737465722f6f6e696f6e2e706e67" alt="洋葱圈"></p><p>写一个小插件<br>新建一个koa-logger.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports = async(cxt, next) =&gt; &#123;</span><br><span class="line">const start = new Date().getTime();</span><br><span class="line">await next();</span><br><span class="line">const end = new Date().getTime();</span><br><span class="line">console.log(cxt.request.url, end-start, cxt.body.length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在server.js里引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const koalog = require(&apos;./koa-logger.js&apos;)</span><br><span class="line">app.use(koalog)</span><br></pre></td></tr></table></figure></p><p>就可以在命令行中显示出地址，耗时。<br><strong>async和await优雅的处理异步</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function ajax() &#123;</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">console.log(&apos;你好&apos;)</span><br><span class="line">&#125;,1000)</span><br><span class="line">&#125;</span><br><span class="line">ajax()</span><br><span class="line">console.log(&apos;sean&apos;)</span><br></pre></td></tr></table></figure></p><p>我们都知道输出sean 1秒之后再输出你好。<br>异步编程的几个方法：<br>1.callback回调函数，很古老的东西了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function ajax(fn) &#123;</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">console.log(&apos;你好&apos;)</span><br><span class="line">fn()//回调函数</span><br><span class="line">&#125;, 1000)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var fn = function () &#123;</span><br><span class="line">console.log(&apos;sean&apos;)</span><br><span class="line">&#125;</span><br><span class="line">ajax(fn)</span><br></pre></td></tr></table></figure></p><p>回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。如果回调函数中再嵌套回调函数的话，就行成了回调地狱（callback hell）<br>2.promise<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function delay(word) &#123;</span><br><span class="line">return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">resolve(word)</span><br><span class="line">&#125;, 1000)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">delay(&apos;鸣人&apos;).then((word) =&gt; &#123;</span><br><span class="line">console.log(word)</span><br><span class="line">return delay(&apos;佐助&apos;)</span><br><span class="line">&#125;).then((word) =&gt; &#123;</span><br><span class="line">console.log(word)</span><br><span class="line">return delay(&apos;小樱&apos;)</span><br><span class="line">&#125;).then((word) =&gt; &#123;</span><br><span class="line">console.log(word)</span><br><span class="line">&#125;)</span><br><span class="line">//鸣人，佐助，小樱</span><br></pre></td></tr></table></figure></p><p>promise链式调用：会将前一个then的返回值（return）作为下一次成功的回调函数的参数。<br>3.async+await (必须一起使用)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function delay(word) &#123;</span><br><span class="line">return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">resolve(word)</span><br><span class="line">&#125;, 1000)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function start() &#123;</span><br><span class="line">const word1 = await delay(&apos;鸣人&apos;)</span><br><span class="line">console.log(word1)</span><br><span class="line">const word2 = await delay(&apos;佐助&apos;)</span><br><span class="line">console.log(word2)</span><br><span class="line">const word3 = await delay(&apos;小樱&apos;)</span><br><span class="line">console.log(word3)</span><br><span class="line">&#125;</span><br><span class="line">start()</span><br></pre></td></tr></table></figure></p><p>简单明了。</p>]]></content>
      
      <categories>
          
          <category> mpvue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mpvue koa </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mpvue开发小程序笔记——3.ES6一些代码片段</title>
      <link href="/2018/06/07/mpvue%E5%BC%80%E5%8F%91%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%943.ES6%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"/>
      <url>/2018/06/07/mpvue%E5%BC%80%E5%8F%91%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%943.ES6%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</url>
      <content type="html"><![CDATA[<p>1.遍历<br>forEach和箭头函数使遍历更优雅.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3, 4]</span><br><span class="line">arr.forEach(v =&gt; console.log(v))</span><br></pre></td></tr></table></figure></p><p>map()函数返回一个新数组，数组中的元素是原始数组元素调用函数处理后的值。every()方法用于检测数组所有元素是否都符合指定条件（通过函数提供）。filter()方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(arr.map(v =&gt; v*2))//[2, 4, 6, 8]</span><br><span class="line">console.log(arr.every(v =&gt; v&gt;0))//true</span><br><span class="line">console.log(arr.filter(v =&gt; v&lt;=3))//[1, 2, 3]</span><br></pre></td></tr></table></figure></p><p>可以链式调用。</p><p>2.去重<br>ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。<br>Set本身是一个构造函数，用来生成Set数据结构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log([...new Set(arr)])</span><br><span class="line">console.log([...new Set([...arr1, ...arr2])])//合并后去重</span><br></pre></td></tr></table></figure></p><p><strong>一个面试题</strong>：淘宝首页一共用到了多少种标签。<br>首先获取所有元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.querySelectorAll(&apos;*&apos;)</span><br></pre></td></tr></table></figure></p><p>map方法返回其所有节点名称<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...document.querySelectorAll(&apos;*&apos;)].map(v =&gt; v.nodeName)</span><br></pre></td></tr></table></figure></p><p>ES6的Set方法去重。size方法返回长度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Set([...document.querySelectorAll(&apos;*&apos;)].map(v =&gt; v.nodeName)).size</span><br></pre></td></tr></table></figure></p><p>一行代码搞定。</p>]]></content>
      
      <categories>
          
          <category> mpvue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mpvue ES6 去重 面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mpvue开发小程序笔记——1.github和git的简单使用</title>
      <link href="/2018/06/07/mpvue%E5%BC%80%E5%8F%91%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%941.github%E5%92%8Cgit%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/06/07/mpvue%E5%BC%80%E5%8F%91%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%941.github%E5%92%8Cgit%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>mpvue开发小程序笔记——1.github和git的简单使用<br>经常写博客，记笔记可以提高学习效率，提升能力，弥补了我的破记性。某位大神曾经说过，当你用自己的话能把一个知识点解释的很明白，那么你就真正的了解了这个知识点。<br>开始开始，能想多少写多少吧。随时补充。<br> 1.注册github，下载git bash。个人感觉gitbash比客户端的github，git gui使用起来效率快。因为我打字蛮快的。。<br> 2.git bash怎么和github联系起来呢？首先绑定用户名和邮箱，用户和邮箱是注册github的用户名和邮箱。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;用户名&quot;</span><br><span class="line">git config --global user.mail &quot;邮箱名&quot;</span><br></pre></td></tr></table></figure></p><p>3.为github设置SSH key<br>ssh key就是加密传输。<br>加密运输的算法有很多，git使用的是rsa。rsa的核心思想就是如何使用一对特定的数字，使其中一个数字可以用来加密，另一个用来解密。这两个数字就是git和github里遇到的public key（公钥）和private key（私钥）<br>所以我们要先在本地生成共钥，再上传到github上，那么从github上发过来的数据都是公钥加密过的，用本地的私钥解密就达到了目的。<br>先检查是否生成密钥 cd ~/.ssh,ls看下如果有3个文件，则密钥已经生成。<br>如果没有，那么通过$ ssh-keygen -t rsa -C “邮箱”来生成。一直回车就OK了。<br>生成之后在电脑里找到这个.ssh文件夹用记事本打开id_rsa.pub，复制里面的一大串东西，这些东西就是公钥。<br>再到github个人，settings里 SSH keys里把这些东西粘贴在下面的Key里。就OK了~此时github的SSH keys就配置完成。</p><ol><li>下面说一下git的一些命令。<br>git init //把这个目录变成Git可以管理的仓库<br>git add README.md //文件添加到仓库<br>git add . //不但可以跟单一文件，还可以跟通配符，更可以跟目录。一个点就把当前目录下所有未追踪的文件全部add了<br>git commit -m “first commit” //把文件提交到仓库<br>git remote add origin git@github.com:gokunaruto/Javascript.git //关联远程仓库<br>git push -u origin master //把本地库的所有内容推送到远程库上</li></ol><p>git clone// 本地空的，将远程仓库复制一份到本地<br>git pull// 本地有库，从远程服务器获取到一个branch分支的更新到本地，并更新本地库，叫做pull.相当于git fetch + merge</p><p>先写这么多~有空在更。</p>]]></content>
      
      <categories>
          
          <category> mpvue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mpvue 小程序 git github </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mpvue开发小程序笔记——2.微信小程序，mpvue和wepy比较一览</title>
      <link href="/2018/06/07/mpvue%E5%BC%80%E5%8F%91%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%942.%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%8Cmpvue%E5%92%8Cwepy%E7%9A%84%E6%AF%94%E8%BE%83%E4%B8%80%E8%A7%88/"/>
      <url>/2018/06/07/mpvue%E5%BC%80%E5%8F%91%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%942.%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%8Cmpvue%E5%92%8Cwepy%E7%9A%84%E6%AF%94%E8%BE%83%E4%B8%80%E8%A7%88/</url>
      <content type="html"><![CDATA[<table><thead><tr><th>/</th><th style="text-align:center">微信小程序</th><th style="text-align:center">mpvue</th><th style="text-align:center">wepy</th></tr></thead><tbody><tr><td>语法规范</td><td style="text-align:center">小程序开发规范</td><td style="text-align:center">VueJS开发规范</td><td style="text-align:center">类Vue开发规范</td></tr><tr><td>标签集合</td><td style="text-align:center">小程序标签</td><td style="text-align:center">html标签+小程序标签</td><td style="text-align:center">小程序标签</td></tr><tr><td>样式规范</td><td style="text-align:center">wxss</td><td style="text-align:center">sass,less,postcss</td><td style="text-align:center">sass,less,styus</td></tr><tr><td>组件化</td><td style="text-align:center">无组件化机制</td><td style="text-align:center">VueJs组件规范</td><td style="text-align:center">自定义组件规范</td></tr><tr><td>多端复用</td><td style="text-align:center">不可复用</td><td style="text-align:center">支持转化为H5</td><td style="text-align:center">支持转化为H5</td></tr><tr><td>自动构建</td><td style="text-align:center">本身无自动构建</td><td style="text-align:center">webpack</td><td style="text-align:center">框架内置自动构建</td></tr><tr><td>上手成本</td><td style="text-align:center">全新学习</td><td style="text-align:center">熟悉VueJs即可</td><td style="text-align:center">VueJs和wepy</td></tr><tr><td>集中数据管理</td><td style="text-align:center">不支持</td><td style="text-align:center">使用Vuex实现</td><td style="text-align:center">不支持</td></tr></tbody></table><p>由此可见。微信小程序学习成本还是比较高的，目前来说，mpvue是最适合学习来开发小程序的。</p>]]></content>
      
      <categories>
          
          <category> mpvue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mpvue 小程序 wepy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>弹跳效果的手风琴下拉菜单</title>
      <link href="/2018/06/01/%E5%BC%B9%E8%B7%B3%E6%95%88%E6%9E%9C%E7%9A%84%E6%89%8B%E9%A3%8E%E7%90%B4%E4%B8%8B%E6%8B%89%E8%8F%9C%E5%8D%95/"/>
      <url>/2018/06/01/%E5%BC%B9%E8%B7%B3%E6%95%88%E6%9E%9C%E7%9A%84%E6%89%8B%E9%A3%8E%E7%90%B4%E4%B8%8B%E6%8B%89%E8%8F%9C%E5%8D%95/</url>
      <content type="html"><![CDATA[<p>一个具有弹跳效果的手风琴下拉菜单。<br>CSS<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* container */</span><br><span class="line">ul.container&#123;width:240px;top:50%;left:50%;position: absolute;transform: translate(-50%,-50%);&#125;</span><br><span class="line">li.menu&#123;padding:5px 0;width:100%;&#125;</span><br><span class="line">li.button a&#123;display:block;font-family:BPreplay,Arial,Helvetica,sans-serif;font-size:21px;height:34px;overflow:hidden;padding:10px 20px 0;position:relative;width:200px;&#125;</span><br><span class="line">li.button a:hover&#123;text-decoration:none;&#125;</span><br><span class="line">li.button a span&#123;height:44px;position:absolute;right:0;top:0;width:4px;display:block;&#125;</span><br><span class="line">li.button a.blue&#123;background:url(../img/blue.png) repeat-x top left; color:#074384;&#125;</span><br><span class="line">li.button a.blue span&#123;background:url(../img/blue.png) repeat-x top right;&#125;</span><br><span class="line">li.button a.green&#123;background:url(../img/green.png) repeat-x top left; color:#436800;&#125;</span><br><span class="line">li.button a.green span&#123;background:url(../img/green.png) repeat-x top right;&#125;</span><br><span class="line">li.button a.orange&#123;background:url(../img/orange.png) repeat-x top left; color:#882e02;&#125;</span><br><span class="line">li.button a.orange span&#123;background:url(../img/orange.png) repeat-x top right;&#125;</span><br><span class="line">li.button a.red&#123;background:url(../img/red.png) repeat-x top left; color:#641603;&#125;</span><br><span class="line">li.button a.red span&#123;background:url(../img/red.png) repeat-x top right;&#125;</span><br><span class="line">li.button a:hover&#123;background-position:bottom left;&#125;</span><br><span class="line">li.button a:hover span&#123;background-position:bottom right;&#125;</span><br><span class="line">.dropdown&#123;display:none;padding-top:5px;width:100%;&#125;</span><br><span class="line">.dropdown li&#123;background-color:#373128;border:1px solid #40392C;color:#CCCCCC;margin:5px 0;padding:4px 18px;&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>HTML<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class=&quot;container&quot;&gt;</span><br><span class="line">&lt;li class=&quot;menu&quot;&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li class=&quot;button&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;green&quot;&gt;HTML&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;dropdown&quot; &gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;Open Grapes Section&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;Close This Section&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;Read on Wikipedia&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;Flickr Stream&lt;/a&gt;&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">&lt;li class=&quot;menu&quot;&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li class=&quot;button&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;orange&quot;&gt;CSS&lt;/a&gt;&lt;/li&gt;          </span><br><span class="line">&lt;li class=&quot;dropdown&quot;&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;Open Last Section&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;Wikipedia Page&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;Flickr Photos&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">&lt;li class=&quot;menu&quot;&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li class=&quot;button&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;blue&quot;&gt;VUE&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li class=&quot;dropdown&quot;&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;Wiki page&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;Text label 1&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;Text label 2&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;Flickr Stream&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p>JS<br>使用JQ实现，引入了easing.js插件实现弹跳效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.4.2.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery.easing.1.3.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">$(document).ready(function()&#123;</span><br><span class="line">$.easing.def = &quot;easeOutBounce&quot;;</span><br><span class="line">$(&apos;li.button a&apos;).click(function(e)&#123;</span><br><span class="line">var dropDown = $(this).parent().next();</span><br><span class="line">$(&apos;.dropdown&apos;).not(dropDown).slideUp(&apos;slow&apos;);</span><br><span class="line">dropDown.slideToggle(&apos;slow&apos;);</span><br><span class="line">e.preventDefault();</span><br><span class="line">&#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>地址：<a href="http://lyb.fun/meau" target="_blank" rel="noopener">效果演示</a></p>]]></content>
      
      <categories>
          
          <category> jquery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jquery 下拉菜单 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>原生js写大图轮播</title>
      <link href="/2018/05/31/%E7%94%A8%E5%8E%9F%E7%94%9FJS%E5%86%99%E5%A4%A7%E5%9B%BE%E8%BD%AE%E6%92%AD/"/>
      <url>/2018/05/31/%E7%94%A8%E5%8E%9F%E7%94%9FJS%E5%86%99%E5%A4%A7%E5%9B%BE%E8%BD%AE%E6%92%AD/</url>
      <content type="html"><![CDATA[<p>轮播图想必大家都不陌生了，各种插件也用的飞起。但是真正的原理是如何实现的呢？<br>今天没事用原生js写了一个轮播图的效果，借用了小米官网的一些大图。废话不多说，直接上代码。<br><strong>CSS</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">margin: 0;</span><br><span class="line">padding: 0</span><br><span class="line">&#125;</span><br><span class="line">#wrap &#123;</span><br><span class="line">width: 1226px;</span><br><span class="line">height: 460px;</span><br><span class="line">position: relative;</span><br><span class="line">margin: 50px auto;</span><br><span class="line">&#125;</span><br><span class="line">.banner &#123;</span><br><span class="line">position: absolute;</span><br><span class="line">opacity: 0</span><br><span class="line">&#125;</span><br><span class="line">.tab &#123;</span><br><span class="line">position: absolute;</span><br><span class="line">bottom: 0;</span><br><span class="line">left: 50%;</span><br><span class="line">transform: translateX(-50%);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">.tab span &#123;</span><br><span class="line">display: inline-block;</span><br><span class="line">width: 10px;</span><br><span class="line">height: 10px;</span><br><span class="line">border-radius: 50%;</span><br><span class="line">margin:3px;</span><br><span class="line">background-color: #fff</span><br><span class="line">&#125;</span><br><span class="line">.tab span:hover &#123;</span><br><span class="line">background-color: #000;</span><br><span class="line">cursor: pointer;</span><br><span class="line">&#125;</span><br><span class="line">.tab span.on &#123;</span><br><span class="line">background-color: #000</span><br><span class="line">&#125;</span><br><span class="line">.prev &#123;</span><br><span class="line">position: absolute;</span><br><span class="line">top: 215px;</span><br><span class="line">left: 20px;</span><br><span class="line">background: url(img/arrow.png) -37px -36px;</span><br><span class="line">width: 30px;</span><br><span class="line">height: 30px;</span><br><span class="line">&#125;</span><br><span class="line">.prev:hover &#123;</span><br><span class="line">background:url(img/arrow.png) 0px -36px;</span><br><span class="line">cursor: pointer;</span><br><span class="line">&#125;</span><br><span class="line">.next &#123;</span><br><span class="line">position: absolute;</span><br><span class="line">top: 215px;</span><br><span class="line">right: 20px;</span><br><span class="line">background: url(img/arrow.png) -37px 0px;</span><br><span class="line">width: 30px;</span><br><span class="line">height: 30px;</span><br><span class="line">&#125;</span><br><span class="line">.next:hover &#123;</span><br><span class="line">background: url(img/arrow.png) 0px 0px;</span><br><span class="line">cursor: pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p><strong>HTML</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;wrap&quot;&gt;</span><br><span class="line">&lt;div class=&quot;banner&quot;&gt;&lt;img src=&quot;img/1.jpg&quot; width=&quot;1226&quot; height=&quot;460&quot; alt=&quot;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;banner&quot;&gt;&lt;img src=&quot;img/2.jpg&quot; width=&quot;1226&quot; height=&quot;460&quot; alt=&quot;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;banner&quot;&gt;&lt;img src=&quot;img/3.jpg&quot; width=&quot;1226&quot; height=&quot;460&quot; alt=&quot;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;banner&quot;&gt;&lt;img src=&quot;img/4.jpg&quot; width=&quot;1226&quot; height=&quot;460&quot; alt=&quot;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;banner&quot;&gt;&lt;img src=&quot;img/5.jpg&quot; width=&quot;1226&quot; height=&quot;460&quot; alt=&quot;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;tab&quot;&gt;</span><br><span class="line">&lt;span&gt;&lt;/span&gt;</span><br><span class="line">&lt;span&gt;&lt;/span&gt;</span><br><span class="line">&lt;span&gt;&lt;/span&gt;</span><br><span class="line">&lt;span&gt;&lt;/span&gt;</span><br><span class="line">&lt;span&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;prev&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;next&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p><strong>JS</strong><br>先获取元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var oBody = document.getElementsByTagName(&apos;body&apos;)[0];</span><br><span class="line">oPrev = document.getElementsByClassName(&apos;prev&apos;)[0];</span><br><span class="line">oNext = document.getElementsByClassName(&apos;next&apos;)[0];</span><br><span class="line">oBanner = document.getElementsByClassName(&apos;banner&apos;);</span><br><span class="line">oSpan = document.getElementsByClassName(&apos;tab&apos;)[0].getElementsByTagName(&apos;span&apos;);</span><br><span class="line">oOn = document.getElementsByClassName(&apos;on&apos;);</span><br></pre></td></tr></table></figure></p><p>初始化第一张图片和第一个小圆点（第一张图片显示，第一个小圆点点击状态）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oBanner[0].style.opacity = &apos;1&apos;;</span><br><span class="line">oSpan[0].className = &apos;on&apos;;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">var num = 0;//定义一个全局变量</span><br><span class="line">for (var i = 0; i &lt; oSpan.length; i++) &#123;</span><br><span class="line">oSpan[i]._index = i;//设置一个_index属性来存储i</span><br><span class="line"></span><br><span class="line">oSpan[i].onclick = function () &#123;//点击小圆点</span><br><span class="line">num = this._index;//将此时点击的_index的值赋值给num</span><br><span class="line">for (var j = 0; j &lt; oSpan.length; j++) &#123;</span><br><span class="line">oSpan[j].className = &apos;&apos;;</span><br><span class="line">oBanner[j].style.opacity = &apos;0&apos;;</span><br><span class="line">&#125;</span><br><span class="line">oSpan[num].className = &apos;on&apos;;</span><br><span class="line">oBanner[num].style.opacity = &apos;1&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">oNext.onclick = function () &#123;</span><br><span class="line">for (var j = 0; j &lt; oSpan.length; j++) &#123;</span><br><span class="line">if (oSpan[j].className == &apos;on&apos;) &#123;</span><br><span class="line">oSpan[j].className = &apos;&apos;;</span><br><span class="line">oBanner[j].style.opacity = &apos;0&apos;;</span><br><span class="line">j++;</span><br><span class="line">num++;</span><br><span class="line">if (j &gt; 4) &#123;</span><br><span class="line">j = 0;</span><br><span class="line">&#125;</span><br><span class="line">oSpan[j].className = &quot;on&quot;;</span><br><span class="line">oBanner[j].style.opacity = &quot;1&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">oPrev.onclick = function () &#123;</span><br><span class="line">for (var j = 0; j &lt; oSpan.length; j++) &#123;</span><br><span class="line">if (oSpan[j].className == &apos;on&apos;) &#123;</span><br><span class="line">oSpan[j].className = &apos;&apos;;</span><br><span class="line">oBanner[j].style.opacity = &apos;0&apos;;</span><br><span class="line">j--;</span><br><span class="line">num--;</span><br><span class="line">if (j &lt; 0) &#123;</span><br><span class="line">j = 4;</span><br><span class="line">&#125;</span><br><span class="line">oSpan[j].className = &quot;on&quot;;</span><br><span class="line">oBanner[j].style.opacity = &quot;1&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">function Time() &#123;</span><br><span class="line">num++;</span><br><span class="line">if (num &lt; 5) &#123;</span><br><span class="line">for (var j = 0; j &lt; oSpan.length; j++) &#123;</span><br><span class="line">oSpan[j].className = &apos;&apos;;</span><br><span class="line">oBanner[j].style.opacity = &apos;0&apos;;</span><br><span class="line">&#125;</span><br><span class="line">oSpan[num].className = &apos;on&apos;;</span><br><span class="line">oBanner[num].style.opacity = &quot;1&quot;;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">num = -1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">clearInterval(timer);</span><br><span class="line">var timer = setInterval(&apos;Time()&apos;, 1000)</span><br><span class="line"></span><br><span class="line">oBody.onmouseover = function () &#123;</span><br><span class="line">clearInterval(timer)</span><br><span class="line">&#125;</span><br><span class="line">oBody.onmouseout = function () &#123;</span><br><span class="line">clearInterval(timer);</span><br><span class="line">timer = setInterval(&apos;Time()&apos;, 1000)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>水平有限，如有错误，请指出(●’◡’●)</p>]]></content>
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 轮播图 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>老生常谈的一个经典问题</title>
      <link href="/2018/05/30/%E8%80%81%E7%94%9F%E5%B8%B8%E8%B0%88%E7%9A%84%E4%B8%80%E4%B8%AA%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/"/>
      <url>/2018/05/30/%E8%80%81%E7%94%9F%E5%B8%B8%E8%B0%88%E7%9A%84%E4%B8%80%E4%B8%AA%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>老生常谈的一个面试题，如何解决点击ul下的每个li，弹出这个li的元素索引呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;111&lt;/li&gt;</span><br><span class="line">&lt;li&gt;222&lt;/li&gt;</span><br><span class="line">&lt;li&gt;333&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p><strong>1. 绑定数据在DOM元素上</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var oLi = document.getElementsByTagName(&apos;li&apos;);</span><br><span class="line">for (var i = 0; i &lt; oLi.length; i++) &#123;</span><br><span class="line">oLi[i]._index = i;</span><br><span class="line">oLi[i].onclick = function () &#123;</span><br><span class="line">alert(this._index + 1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>遍历oLi，设置一个属性_index来记录i。<br><strong>2. 闭包</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var oLi = document.getElementsByTagName(&apos;li&apos;);</span><br><span class="line">for (var i = 0; i &lt; oLi.length; i++) &#123;</span><br><span class="line">oLi[i].onclick = fn(i)</span><br><span class="line">&#125;</span><br><span class="line">function fn(j) &#123;</span><br><span class="line">return function() &#123;</span><br><span class="line">alert(j + 1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>IIFE写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var oLi = document.getElementsByTagName(&apos;li&apos;);</span><br><span class="line">for (var i = 0; i &lt; oLi.length; i++) &#123;</span><br><span class="line">oLi[i].onclick = (function(j)&#123;</span><br><span class="line">return function() &#123;</span><br><span class="line">alert(j + 1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样的写法是最常见的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var oLi = document.getElementsByTagName(&apos;li&apos;);</span><br><span class="line">for (var i = 0; i &lt; oLi.length; i++) &#123;</span><br><span class="line">(function (j) &#123;</span><br><span class="line">oLi[j].onclick = function () &#123;</span><br><span class="line">alert(j + 1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>3. let</strong><br>超级简单，ES6使用let就是为了解决作用域的问题。ES5的一些方法要逐渐淘汰了~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var oLi = document.getElementsByTagName(&apos;li&apos;);</span><br><span class="line">for (let i = 0; i &lt; oLi.length; i++) &#123;</span><br><span class="line">oLi[i].onclick = function() &#123;</span><br><span class="line">alert( i + 1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>4. 事件委托</strong><br>先将带有length属性的元素转换为数组，然后利用数组的indexOf方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var oLi = document.getElementsByTagName(&apos;li&apos;);</span><br><span class="line">ali = Array.prototype.slice.call(oLi);</span><br><span class="line">oUl = document.getElementsByTagName(&apos;ul&apos;)[0];</span><br><span class="line">oUl.addEventListener(&apos;click&apos;, function () &#123;</span><br><span class="line">var event = event || window.event;</span><br><span class="line">var target = event.target || event.srcElement;</span><br><span class="line">alert(ali.indexOf(target) + 1)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>本人水平有限，如有错误，还望指出 ^_^”</p>]]></content>
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 javascript 作用域 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Exercising Trip (数组)</title>
      <link href="/2018/05/24/Exercising%20Trip%20%EF%BC%88%E6%95%B0%E7%BB%84%EF%BC%89/"/>
      <url>/2018/05/24/Exercising%20Trip%20%EF%BC%88%E6%95%B0%E7%BB%84%EF%BC%89/</url>
      <content type="html"><![CDATA[<hr><p><strong>说在前面的话:</strong><br><strong>数组的concat,join,slice,toString方法不会改变原数组。<br>数组的splice,push,pop,unshift,shift,sort,reverse方法会改变原数组。</strong></p><p><strong>1. 数组求和</strong></p><blockquote><p>要求:计算给定数组的所有元素的总和，数组的元素均为Numeber，不考虑其它类型。</p></blockquote><p>方法一：常规遍历相加<br>for，for in, for of, forEach都可以遍历数组！这里我用了for in<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function sum (arr) &#123;</span><br><span class="line">var res = 0;</span><br><span class="line">for (var i in arr)&#123;</span><br><span class="line">res += arr[i]</span><br><span class="line">&#125;</span><br><span class="line">return res</span><br><span class="line">&#125;</span><br><span class="line">console.log(sum([1, 2, 3, 4]))</span><br></pre></td></tr></table></figure></p><p>关于for循环的作用域问题可以参考我的另一篇博客<a href="http://lyb.fun/2018/05/22/ES6%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">ES6总结</a>。<br><a id="more"></a><br>方法二： 递归!<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 9]</span><br><span class="line">function sum(arr) &#123;</span><br><span class="line">var len = arr.length;</span><br><span class="line">if (len == 0) &#123;</span><br><span class="line">return 0</span><br><span class="line">&#125; else if (len == 1) &#123;</span><br><span class="line">return arr[0]</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return arr[0] + sum(arr.slice(1))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(sum(arr))</span><br></pre></td></tr></table></figure></p><p>方法三： reduce()<br>reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。<br>reduce/map,filter,sort都是高阶函数!可以接受函数作为参数！（给高阶大佬们倒茶！）关于用法我将专门写一篇来说。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 2, 3, 22, 2]</span><br><span class="line">function sum (arr) &#123;</span><br><span class="line">    var res = arr.reduce(function (total, num) &#123;</span><br><span class="line">      return  total + num</span><br><span class="line">    &#125;)</span><br><span class="line">    return res</span><br><span class="line">&#125;</span><br><span class="line">console.log(sum(arr))</span><br></pre></td></tr></table></figure></p><p>方法四： eval()<br>(发音：哎喔~~ ）eval接受字符串，并计算其javascript代码。黑科技啊有木有！但是不推荐用！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5];</span><br><span class="line">function sum(arr) &#123;</span><br><span class="line">return eval(arr.join(&apos;+&apos;))</span><br><span class="line">&#125;</span><br><span class="line">console.log(sum(arr))</span><br></pre></td></tr></table></figure></p><p><strong>2. 数组求最大值</strong><br>其实数组的一些操作变来变去就那些。以不变应万变，多写写，多思考，熟练了这些方法基本就可以应付一切数组的问题了！<br>方法一： for循环遍历<br>简单！取第一个元素，遍历数组的元素挨个比较，取最大值！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 9]</span><br><span class="line">function max(arr) &#123;</span><br><span class="line">var res = arr[0]</span><br><span class="line">for (var i in arr) &#123;</span><br><span class="line">res = Math.max(res, arr[i])</span><br><span class="line">&#125;</span><br><span class="line">return res</span><br><span class="line">&#125;</span><br><span class="line">console.log(max(arr))</span><br></pre></td></tr></table></figure></p><p>方法二： sort()和reverse()<br>思路很简单，从大到小排序然后第一个元素就是最大值咯！（这里我不明白为什么sort接受这样一个函数就可以实现排序了呢？容我研究研究~~）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4]</span><br><span class="line">var res = arr.sort((a, b) =&gt; b - a)[0]</span><br><span class="line">console.log(res)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var res = arr.sort((a, b) =&gt; a - b).reverse()[0]</span><br></pre></td></tr></table></figure><p>方法三： Math.max()<br>这个就很有意思了，apply可以劫持另一个对象的方法，也就是说可以继承这个方法!这里第一个参数null只是表示一个占位符。类似的有Array.prototy.push.apply(arr1, arr2)。可以理解为arr1劫持了push方法，传入参数arr2。即为arr1.push(arr2)。apply方法已经将arr2数组转换为参数列表，call跟apply的用法差不多，call是apply的语法糖。（我在考虑要不要单独写一偏关于apply,call,bind的用法)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4]</span><br><span class="line">console.log(Math.max.apply(null, arr))</span><br></pre></td></tr></table></figure></p><p>方法四： reduce()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 2, 3, 22, 2]</span><br><span class="line">var max = arr.reduce(function (a, b) &#123;return a &gt; b ? a : b&#125;)</span><br><span class="line">console.log(max)</span><br></pre></td></tr></table></figure></p><p>方法五： eval()<br>(还是这个鬼东西!) 不废话！上代码！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4]</span><br><span class="line">var max = eval(&apos;Math.max(&apos; + arr + &apos;)&apos;)</span><br><span class="line">console.log(max) //4</span><br></pre></td></tr></table></figure></p><p>在这里，arr不需要转换成字符串再相加，因为加号可以隐式的将数组对象转成字符串。<br><strong>3. 数组合并</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//concat 这个不用解释了，简单粗暴</span><br><span class="line">function concat(arr1, arr2) &#123;</span><br><span class="line">return arr = arr1.concat(arr2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//slice和push 深拷贝一份arr1,遍历arr2，push进去就OK了！</span><br><span class="line">function concat(arr1, arr2) &#123;</span><br><span class="line">var arr = arr1.slice(0);</span><br><span class="line">for (var i in arr2) &#123;</span><br><span class="line">arr.push(arr2[i])</span><br><span class="line">&#125;</span><br><span class="line">return arr</span><br><span class="line">&#125;</span><br><span class="line">var arr1 = [1, 2];</span><br><span class="line">var arr2 = [3, 4];</span><br><span class="line">console.log(concat(arr1, arr2))</span><br><span class="line"></span><br><span class="line">//slice，push,apply 跟上面用法差不多</span><br><span class="line">function concat(arr1, arr2) &#123;</span><br><span class="line">var arr = arr1.slice(0);</span><br><span class="line">Array.prototype.push.apply(arr, arr2)//[].push.apply(arr, arr2)也可以</span><br><span class="line">return arr</span><br><span class="line">&#125;</span><br><span class="line">var arr1 = [1, 2];</span><br><span class="line">var arr2 = [3, 4];</span><br><span class="line">console.log(concat(arr1, arr2))</span><br><span class="line"></span><br><span class="line">//for循环遍历，分别push</span><br><span class="line">function concat(arr1, arr2) &#123;</span><br><span class="line">var arr = [];</span><br><span class="line">for (var i in arr1) &#123;</span><br><span class="line">arr.push(arr1[i])</span><br><span class="line">&#125;</span><br><span class="line">for (var j in arr2) &#123;</span><br><span class="line">arr.push(arr2[j])</span><br><span class="line">&#125;</span><br><span class="line">return arr</span><br><span class="line">&#125;</span><br><span class="line">var arr1 = [1, 2];</span><br><span class="line">var arr2 = [3, 4];</span><br><span class="line">console.log(concat(arr1, arr2))</span><br></pre></td></tr></table></figure></p><p> <strong>4. 数组中元素的相关操作</strong></p><p> 1.移除数组 arr 中的所有值与 item 相等的元素，直接在给定的 arr 数组上进行操作，并将结果返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 2, 3, 4, 2]</span><br><span class="line">function sum(arr, item) &#123;</span><br><span class="line">for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">if (arr[i] == item) &#123;</span><br><span class="line"> arr.splice(i, 1)</span><br><span class="line"> i--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return arr</span><br><span class="line">&#125;</span><br><span class="line">console.log(sum(arr, 2))    // [1, 3, 4]</span><br><span class="line">console.log(arr)    //[1, 3, 4]</span><br></pre></td></tr></table></figure></p><p>注意！因为splice会改变原数组的长度，所以每次删除之后i-1;在这里不能用for in循环。因为for in会遍历对象的所有可枚举属性，并且原型上的属性也会被访问到，只要这个属性是存在并且可枚举的，他就会给你全部打印出来。而且for in性能最差，所以对于<strong>数组最好用for循环，处理对象用for in</strong>.<br>链接：<a href="https://www.imooc.com/article/12984" target="_blank" rel="noopener">for in循环和for循环的区别</a></p><p> 2.在数组 arr 中，查找值与 item 相等的元素出现的所有位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//forEach</span><br><span class="line">var arr = [1, 2, 2, 3, 4, 2]</span><br><span class="line">function fn(arr, item) &#123;</span><br><span class="line">var res = [];</span><br><span class="line">arr.forEach(function (value, index) &#123;</span><br><span class="line">return value !== item || res.push(index) //value == item &amp;&amp; res.push(index)</span><br><span class="line">&#125;)</span><br><span class="line">return res</span><br><span class="line">&#125;   </span><br><span class="line">console.log(fn(arr, 2)) //[1, 2, 5]</span><br></pre></td></tr></table></figure></p><p>3.找出数组 arr 中重复出现过的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//双层遍历。</span><br><span class="line">var arr = [1, 2, 2, 3, 22, 2]</span><br><span class="line">  function sum (arr) &#123;</span><br><span class="line">  var res = [];</span><br><span class="line">  for (var i = 0; i &lt;arr.length-1; i++) &#123;</span><br><span class="line">  for (var j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">  if (arr[i] === arr[j] &amp;&amp; res.indexOf(arr[i]) == -1 ) &#123; //判断是否重复，是否放进新数组</span><br><span class="line">  res.push(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(sum(arr))</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//sort排序后遍历相邻的</span><br><span class="line">var arr = [1, 2, 2, 3, 22, 2]</span><br><span class="line">  function sum (arr) &#123;</span><br><span class="line">  var res = [];</span><br><span class="line">  arr.sort();</span><br><span class="line">  for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">  if (arr[i] === arr[i+1] &amp;&amp; res.indexOf(arr[i]) == -1) &#123;</span><br><span class="line">  res.push(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(sum(arr))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//filter</span><br><span class="line">var arr = [1, 2, 2, 3, 22, 2]</span><br><span class="line">  function sum (arr) &#123;</span><br><span class="line">  return arr.sort().filter(function(item, i) &#123;</span><br><span class="line">  return arr[i] == arr[i+1] &amp;&amp; arr[i] !== arr[i-1]</span><br><span class="line">  &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(sum(arr))</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> javascript 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数组相关面试题</title>
      <link href="/2018/05/22/tags-%20%E6%95%B0%E7%BB%84/"/>
      <url>/2018/05/22/tags-%20%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<h3 id="1-统计一个字符串中出现最多的字符。"><a href="#1-统计一个字符串中出现最多的字符。" class="headerlink" title="1. 统计一个字符串中出现最多的字符。"></a>1. 统计一个字符串中出现最多的字符。</h3><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;wangxiaoaiwangxiaoting&apos;;</span><br><span class="line">var o = &#123;&#125;;</span><br><span class="line">for(var i = 0; i &lt; str.length; i++) &#123;</span><br><span class="line">var char = str.charAt(i);</span><br><span class="line">// console.log(char);</span><br><span class="line">if(o[char])&#123;     //obj.name 和 obj[&apos;name&apos;]</span><br><span class="line">o[char]++  //如果对象有这个属性了，就给这个属性自增1</span><br><span class="line">&#125;else&#123;</span><br><span class="line">o[char] = 1  //如果对象没这个属性，就个这个属性值设为1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(o);</span><br><span class="line">var num = 0;</span><br><span class="line">var number = &apos;&apos;;</span><br><span class="line">for (var i in o) &#123; //for in循环 遍历对象的属性和方法</span><br><span class="line">if(num &lt; o[i])&#123;</span><br><span class="line">num = o[i];</span><br><span class="line">number = i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(&apos;最多出现的字符是:&apos;+number+&apos;,&apos;+&apos;次数是&apos;+num)</span><br></pre></td></tr></table></figure> <a id="more"></a><h3 id="2-数组去重的几种方法"><a href="#2-数组去重的几种方法" class="headerlink" title="2. 数组去重的几种方法"></a>2. 数组去重的几种方法</h3><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,1,2,2,7,5,7,5,4,3,3,4,&apos;a&apos;,&apos;c&apos;,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;b&apos;]</span><br><span class="line">//方法一：利用对象属性的存在的特性，如果没有该属性则存入数组</span><br><span class="line">function unique1(arr) &#123;</span><br><span class="line">var res = [];</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">for(var i = 0; i&lt;arr.length; i++)&#123;</span><br><span class="line">if(!obj[arr[i]])&#123;   //obj[arr[i]]为obj对象的属性值</span><br><span class="line">obj[arr[i]] = 1;</span><br><span class="line">res.push(arr[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">console.log(unique1(arr));</span><br><span class="line"></span><br><span class="line">//方法二：利用数组的indexOf</span><br><span class="line">function unqiue2(arr) &#123;</span><br><span class="line">var res = [];</span><br><span class="line">for(var i = 0; i&lt;arr.length; i++)&#123;</span><br><span class="line">if(res.indexOf(arr[i])==-1)&#123;  //或 arr.indexOf(arr[i])==i,即arr[i]第一次出现就push进res，再次出现就不符合条件，不再push。</span><br><span class="line">res.push(arr[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">console.log(unqiue2(arr));</span><br><span class="line"></span><br><span class="line">//方法三：数组原型对象上的的includes方法</span><br><span class="line">function unique3(arr) &#123;</span><br><span class="line">var res = [];</span><br><span class="line">for(var i = 0 ;i &lt; arr.length; i++)&#123;</span><br><span class="line">if(!res.includes(arr[i]))&#123;</span><br><span class="line">res.push(arr[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">console.log(unique3(arr));</span><br><span class="line"></span><br><span class="line">//方法四：排序后相邻去重 思路：原数组排序，排序后相同值相邻，然后遍历时新数组只传入不与前一个值相同的值</span><br><span class="line">function unique4(arr) &#123;</span><br><span class="line">arr.sort();  //排序后arr已经改变了</span><br><span class="line">var res = [arr[0]];</span><br><span class="line">for(var i = 1; i&lt;arr.length; i++)&#123;</span><br><span class="line">if(arr[i] !== res[res.length-1])&#123;</span><br><span class="line">res.push(arr[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">console.log(unique4(arr));</span><br><span class="line"></span><br><span class="line">//方法五：优化遍历数组</span><br><span class="line">function unique5(arr) &#123;</span><br><span class="line">var res = [];</span><br><span class="line">for(var i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">for(var j = i+1; j &lt; arr.length; j++)&#123;</span><br><span class="line">if(arr[i] == arr[j])&#123;</span><br><span class="line"> ++ i;  //与右边的元素依次比较，若有重复，则跳出内层循环，重新开始。</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res.push(arr[i])</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br><span class="line">&#125;</span><br><span class="line">console.log(unique5(arr))</span><br><span class="line"></span><br><span class="line">//方法六：ES6 Set数据结构类似于数组，其成员都是唯一的 IE系列不兼容</span><br><span class="line">function unique6(arr) &#123;</span><br><span class="line">// return Array.from(new Set(arr)) ;//Array.from 将Set结构转换成数组</span><br><span class="line">return [...(new Set(arr))]</span><br><span class="line">&#125;</span><br><span class="line">console.log(unique6(arr))</span><br><span class="line"></span><br><span class="line">//方法七：ES6 </span><br><span class="line">function unique7(arr) &#123;</span><br><span class="line">const res = new Map();</span><br><span class="line">return arr.filter((a)=&gt;!res.has(a)&amp;&amp;res.set(a,1))</span><br><span class="line">&#125;</span><br><span class="line">console.log(unique7(arr));</span><br></pre></td></tr></table></figure><h3 id="3-数组clone-深、浅拷贝"><a href="#3-数组clone-深、浅拷贝" class="headerlink" title="3. 数组clone(深、浅拷贝)"></a>3. 数组clone(深、浅拷贝)</h3><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = arr.concat();//方法1 concat()，深拷贝</span><br><span class="line">var arr2 = arr.slice(0);//方法2slice()，深拷贝</span><br><span class="line">var arr3 = [];//方法3for循环,浅拷贝</span><br><span class="line">for(var i in arr)&#123;</span><br><span class="line">arr3[i] = arr[i]</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 深拷贝 ,如果数组里含有对象</span><br><span class="line"> */</span><br><span class="line">function deepClone(arr) &#123;</span><br><span class="line">var res = [];</span><br><span class="line">for (var i in arr)&#123;</span><br><span class="line">if (typeof arr[i] === &apos;object&apos;) &#123; //如果含有对象，则递归</span><br><span class="line">res[i] = deepClone(arr[i])</span><br><span class="line">&#125;else&#123;</span><br><span class="line">res[i] = arr[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-找出数组中的最大值"><a href="#4-找出数组中的最大值" class="headerlink" title="4. 找出数组中的最大值"></a>4. 找出数组中的最大值</h3><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var arrMax = [1,2,3,4,5];</span><br><span class="line">//1.for循环,古老的写法，遍历之后取最大值</span><br><span class="line">var arrRes = arrMax[0];</span><br><span class="line">for(var i = 1 ;i &lt;arrMax.length; i++)&#123;</span><br><span class="line">var result = Math.max(arrRes,arrMax[i]) </span><br><span class="line">&#125;</span><br><span class="line">console.log(result)</span><br><span class="line">//2.Math最大值。用到apply方法，可以将数组转换成参数列表再调用Math方法</span><br><span class="line">Math.max.apply(null,arrMax)</span><br><span class="line">//3.sort()</span><br><span class="line">arrMax.sort((num1,num2) =&gt; &#123;return num2-num1&#125;)[0] //或者sort()后reverse() </span><br><span class="line">//4.reduce()</span><br><span class="line">arrMax.reduce((num1,num2) =&gt; &#123;return num1 &gt; num2 ? num1 : num2&#125;)</span><br></pre></td></tr></table></figure><h3 id="5-数组降维"><a href="#5-数组降维" class="headerlink" title="5. 数组降维"></a>5. 数组降维</h3><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var arrDown = [[1,2,3],[4,5],[9,8,7]];</span><br><span class="line">//1.二维数组，双层遍历</span><br><span class="line">function down(arr) &#123;</span><br><span class="line">var resDown = [];</span><br><span class="line">for(var i = 0;i &lt; arr.length; i++)&#123;</span><br><span class="line">for (var j = 0; j &lt; arr[i].length; j++)&#123;</span><br><span class="line">resDown.push(arr[i][j])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return resDown</span><br><span class="line">&#125;</span><br><span class="line">console.log(down(arrDown))</span><br><span class="line">//2.concat()</span><br><span class="line">function down2(arr) &#123;</span><br><span class="line">var resDown = [];</span><br><span class="line">for(var i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">resDown = resDown.concat(arr[i])</span><br><span class="line">&#125;</span><br><span class="line">return resDown</span><br><span class="line">&#125;</span><br><span class="line">console.log(down2(arrDown))</span><br><span class="line">//3.concat()和apply()结合</span><br><span class="line">function down3(arr) &#123;</span><br><span class="line">var resDown = [];</span><br><span class="line">return Array.prototype.concat.apply(resDown,arr)</span><br><span class="line">&#125;</span><br><span class="line">console.log(down3(arrDown))</span><br></pre></td></tr></table></figure><h3 id="6-数组排序"><a href="#6-数组排序" class="headerlink" title="6. 数组排序"></a>6. 数组排序</h3><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//1.冒泡排序</span><br><span class="line">var arrs = [3,2,5,9,1,6,33,4,65,22];</span><br><span class="line">var temp = 0;</span><br><span class="line">for(var i = 0; i &lt; arrs.length; i++)&#123;</span><br><span class="line">for(var j = i+1; j &lt; arrs.length;j++)&#123; </span><br><span class="line">     if(arrs[i] &gt; arrs[j])&#123; //相邻比较，如果前一个大，就调换位置</span><br><span class="line">temp = arrs[i];//temp储存前一个大的数</span><br><span class="line">arrs[i] = arrs[j];//前一个换成小的那个数</span><br><span class="line">arrs[j] = temp//将大的赋值给后一个</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(arrs)</span><br><span class="line">//2.快速排序</span><br><span class="line">function quickSort(arr) &#123;</span><br><span class="line">if(arr.length &lt;= 1) return arr;</span><br><span class="line">var middleIndex = Math.floor(arr.length/2);//取中间值</span><br><span class="line">var middle = arr.splice(middleIndex,1);//删除并返回这个值，即把中间这个值拿出来用作比较</span><br><span class="line">var left = [];</span><br><span class="line">var right = [];</span><br><span class="line">for(var i = 0; i &lt; arr.length; i ++)&#123;</span><br><span class="line">if(arr[i] &gt; middle)&#123;  //遍历，比这个大的放在right数组，小的放在left数组</span><br><span class="line">right.push(arr[i])</span><br><span class="line">&#125;else&#123;</span><br><span class="line">left.push(arr[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return quickSort(left).concat(middle,quickSort(right));//递归 直到length&lt;=1</span><br><span class="line">&#125;</span><br><span class="line">console.log(quickSort(arrs));</span><br><span class="line">//3.选择排序</span><br><span class="line">function selectSort(arr) &#123;</span><br><span class="line">var minIndex, temp;</span><br><span class="line">for(var i = 0; i &lt; arr.length-1; i++)&#123;</span><br><span class="line"> minIndex = i;</span><br><span class="line">for(var j = i+1; j&lt;arr.length; j++)&#123;</span><br><span class="line">if(arr[j] &lt; arr[minIndex])&#123;</span><br><span class="line">minIndex = j</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">temp = arr[i];</span><br><span class="line">arr[i] =arr[minIndex];</span><br><span class="line">arr[minIndex] = temp;</span><br><span class="line">&#125;</span><br><span class="line">return arr;</span><br><span class="line">&#125;</span><br><span class="line">console.log(selectSort(arrs))</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo搭建博客遇到的一些坑</title>
      <link href="/2018/05/22/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/"/>
      <url>/2018/05/22/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</url>
      <content type="html"><![CDATA[<h3 id="1-本地搜索功能不能使用，git-bash提示hexo-generatto-searchdb模块缺少cdata"><a href="#1-本地搜索功能不能使用，git-bash提示hexo-generatto-searchdb模块缺少cdata" class="headerlink" title="1.本地搜索功能不能使用，git bash提示hexo-generatto-searchdb模块缺少cdata"></a>1.本地搜索功能不能使用，git bash提示hexo-generatto-searchdb模块缺少cdata</h3><p>解决办法：<br>cnpm install hexo-generator-search –save<br>cnpm install hexo-generator-searchdb –save</p><h3 id="2-ERROR-Deployer-not-found-git"><a href="#2-ERROR-Deployer-not-found-git" class="headerlink" title="2.ERROR Deployer not found: git"></a>2.ERROR Deployer not found: git</h3><p>解决办法：<br>cnpm install hexo-deployer-git –save</p><h3 id="3-wordcout插件错误"><a href="#3-wordcout插件错误" class="headerlink" title="3.wordcout插件错误"></a>3.wordcout插件错误</h3><p>解决办法：<br>cnpm install hexo-wordcount –save</p>]]></content>
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ES6相关总结（随时补充）</title>
      <link href="/2018/05/22/ES6%E6%80%BB%E7%BB%93/"/>
      <url>/2018/05/22/ES6%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>网上杂七杂八的ES6语法看的眼花缭乱，今天没事自己总结下一些常用的，加深下印象。<br>ES6是什么东东呢，其实就是JavaScript的下一代标准。全称ECMAScrpt 6.0。大家常说的ES2015其实就是ES6的第一个版本。其实不必纠结这些。它们俩没啥区别，都指下一代JS标准。<br>下面列举下常见的新功能。</p><h3 id="1-let和const"><a href="#1-let和const" class="headerlink" title="1. let和const"></a><strong>1. let和const</strong></h3><p>这个算是高频使用的了，ES6里代替var，let定义变量，const定义常量。</p><ul><li><p><strong>let</strong></p><p>跟ES5相比，有两点不同.<br>一是不存在变量提升：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(a)   // undefined</span><br><span class="line">console.log(b)   // 报错：b未定义</span><br><span class="line">var a = 1</span><br><span class="line">let b = 1</span><br></pre></td></tr></table></figure></li></ul><p>因为let不存在变量提升，所以会有所谓的暂时性死区（这个区块中变量未声明之前，对该变量的一切调用都会报错）。其实ES6这样设计的目的就是为了让我们养成规范的代码习惯，先声明再调用。这一点一定要注意。</p><p>二是let声明的变量不能重复声明，否则会报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var i = 1;</span><br><span class="line">var i = 2;</span><br><span class="line">console.log(i)//2</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let i = 1;</span><br><span class="line">let i = 2;</span><br><span class="line">console.log(i)//报错</span><br></pre></td></tr></table></figure><p>当然在不同的区块内重复声明就可以，比如for循环其实就是2个区块，（）的可以理解为父作用域，{}里的为子作用域。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(let i = 0; i &lt; 5; i++)&#123;</span><br><span class="line">  let i = 7；</span><br><span class="line">  console.log(i)</span><br><span class="line">&#125;</span><br><span class="line">// 输出结果是5个7</span><br></pre></td></tr></table></figure></p><p>这里没有报错，说明（）和{}其实是2个作用域。<br><a id="more"></a><br>三是新增了块级作用域。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i &lt; 5; i++)&#123;</span><br><span class="line">&#125;</span><br><span class="line">console.log(i) // 5</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(let i = 0; i &lt; 5; i++)&#123;      // 这个i只能在这个for循环内使用</span><br><span class="line">&#125;</span><br><span class="line">console.log(i) // 报错：i is not defined</span><br></pre></td></tr></table></figure><p>一个常见的闭包问题就可以用let来解决。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i &lt; 5; i++)&#123;</span><br><span class="line">  setTimeout(function()&#123;</span><br><span class="line">      console.log(i)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个可谓是经典的闭包题了，结果是一次性输出5个5。如何让它输出01234呢，ES5我们用IIFE来解决。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i &lt; 5; i++)&#123;</span><br><span class="line">  (function(e)&#123;</span><br><span class="line">      setTimeout(function()&#123;</span><br><span class="line">          console.log(e)</span><br><span class="line">      &#125;, 1000)        </span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将代码放在一个IIFE中创建了一个独立的作用域，传入i,这样就实现了对i的暂存。(详细可参看我的另一篇关于闭包的文章。)<br>ES6就可以用let来解决了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(let i = 0; i &lt; 5; i++)&#123;</span><br><span class="line">  setTimeout(function()&#123;</span><br><span class="line">      console.log(i)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实JS引擎解析上述代码中的let,就是按照ES5的规范来解析的。即创建一个IIFE传入i.</p><ul><li>const<br>1.声明的时候就要初始化，否则会报错<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const a ;//报错</span><br></pre></td></tr></table></figure></li></ul><p>2.声明的值不能改变，不能重复声明，不存在变量提升。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const a = 1;</span><br><span class="line">let a = 2//报错</span><br><span class="line">var a = 2//报错</span><br><span class="line">a = 2//报错</span><br></pre></td></tr></table></figure></p><p>想到的就这么多，随时补充。</p><h3 id="2-箭头函数"><a href="#2-箭头函数" class="headerlink" title="2. 箭头函数"></a><strong>2. 箭头函数</strong></h3><p>这尼玛是巅峰了js的编码习惯，一点都不适应好嘛！！还是超喜欢以前笨笨的写法。。<br>废话不多说，用法如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var fn = function(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;//es5</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var fn = (a, b) =&gt; a + b//es6</span><br></pre></td></tr></table></figure><p>总结下几种情况下的写法：<br>() =&gt; { … } // 零个参数用 () 表示<br>x =&gt; { … } // 一个参数可以省略 ()<br>(x, y) =&gt; { … } // 多参数不能省略 ()<br>箭头函数最直观的特点就是：<strong>不需要function关键字创建函数，省略return关键字，继承上下文的this关键字。</strong></p><p><strong>重点来了！重点来了！</strong>这里着重说一下<strong>this</strong>,这个可谓是箭头函数里最重要的也是面试中最容易考察的问题。<br>我们都知道在<strong>普通函数</strong>里。this的使用情况如下：</p><ul><li>this指代它的直接调用者。比如a.fn()。fn()里的this指向a。</li><li>使用call,apply,bind时，this指向绑定的对象。a.call(b,..) this指向b。比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var sayName = function () &#123;  </span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var peter = &#123;  </span><br><span class="line">    name: &quot;peter&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayName.call(peter);//peter</span><br></pre></td></tr></table></figure></li></ul><p>使用了call，this就指向了peter，peter继承了sayName方法。this.name即为peter.name。</p><ul><li>非严格模式下，没直接调用者，this即指向window。</li><li>严格模式下（’use strict’），没直接调用者，this是undefind。</li></ul><p>那么在<strong>箭头函数</strong>中。它没有自己的this,它的this继承而来，即定义时所在的上下文的this。<br>普通函数中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var x=11;</span><br><span class="line">var obj=&#123;</span><br><span class="line"> x:22,</span><br><span class="line"> say:function() &#123;</span><br><span class="line">    console.log(this.x)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.say();//22 this指向obj</span><br></pre></td></tr></table></figure></p><p>箭头函数中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var x=11;</span><br><span class="line">var obj=&#123;</span><br><span class="line"> x:22,</span><br><span class="line"> say:()=&gt;&#123;</span><br><span class="line">   console.log(this.x);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.say();//11 this指向window</span><br></pre></td></tr></table></figure></p><p>此时this在obj内定义的，指代window。</p><h3 id="3-模板字符串"><a href="#3-模板字符串" class="headerlink" title="3. 模板字符串"></a><strong>3. 模板字符串</strong></h3><p>模板字符串就是为了解决使用+拼接字符串的不便利而出现的。它有三个用法</p><ul><li>多行文本</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;&lt;html&gt;&apos;</span><br><span class="line">+ &apos;&lt;div&gt;啦拉拉&lt;/div&gt;&apos;</span><br><span class="line">+ &apos;&lt;div&gt;xixixi&lt;/div&gt;&apos;</span><br><span class="line">+ &apos;&lt;/html&gt;&apos;;</span><br><span class="line">console.log(str);// &lt;html&gt;&lt;div&gt;啦拉拉&lt;/div&gt;&lt;div&gt;xixixi&lt;/div&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>ES6中就可以这样写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let str = `&lt;html&gt;</span><br><span class="line">    &lt;div&gt;啦拉拉&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;xixixix&lt;/div&gt;</span><br><span class="line">&lt;/html&gt;`;</span><br><span class="line"></span><br><span class="line">console.log(str);</span><br></pre></td></tr></table></figure></p><ul><li>插入变量或表达式<br>可在${}中插入变量或表达式。<br>ES5中用+来拼接字符串。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var name =  &apos;sean&apos;;</span><br><span class="line">var age = 26;</span><br><span class="line">var info = &apos;my name is &apos; + name + &apos;,age is &apos; + age;</span><br><span class="line">console.log(info)//my name is sean,age is 26</span><br></pre></td></tr></table></figure></li></ul><p>ES6中就可以这样写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let name =  &apos;sean&apos;;</span><br><span class="line">let age = 26;</span><br><span class="line">let info = `my name is $&#123;name&#125;,age is $&#123;age&#125;,like $&#123;age+1&#125;`;</span><br><span class="line">console.log(info)//my name is sean,age is 26,like 27</span><br></pre></td></tr></table></figure></p><p>很方便的样子哦。刚开始是有点别扭，多用用就熟练了。</p><h3 id="4-解析结构"><a href="#4-解析结构" class="headerlink" title="4. 解析结构"></a><strong>4. 解析结构</strong></h3><p>所谓解构就是ES6中新增的功能，它可以从数组或对象中取出数据保存为变量。<br>ES5中我们是这样提取信息的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const people = &#123;</span><br><span class="line">        name: &apos;sean&apos;,</span><br><span class="line">        age: 20</span><br><span class="line">    &#125;</span><br><span class="line">    const name = people.name</span><br><span class="line">    const age = people.age</span><br><span class="line">    console.log(name + &apos; --- &apos; + age)</span><br></pre></td></tr></table></figure></p><p>ES6中这样使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//对象</span><br><span class="line">    const people = &#123;</span><br><span class="line">        name: &apos;sean&apos;,</span><br><span class="line">        age: 20</span><br><span class="line">    &#125;</span><br><span class="line">    const &#123; name, age &#125; = people//保存数据为变量</span><br><span class="line">    console.log(`$&#123;name&#125; --- $&#123;age&#125;`)//用模板字符串方式打印出来</span><br><span class="line">//数组</span><br><span class="line">    const color = [&apos;red&apos;, &apos;blue&apos;]</span><br><span class="line">    const [first, second] = color</span><br><span class="line">    console.log(first) //&apos;red&apos;</span><br><span class="line">    console.log(second) //&apos;blue&apos;</span><br></pre></td></tr></table></figure></p><h3 id="5-函数的默认参数"><a href="#5-函数的默认参数" class="headerlink" title="5. 函数的默认参数"></a><strong>5. 函数的默认参数</strong></h3><p>ES5中是这样定义函数的默认参数的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function action(num) &#123;</span><br><span class="line">    num = num || 200</span><br><span class="line">    //当传入num时，num为传入的值</span><br><span class="line">    //当没传入参数时，num即有了默认值200</span><br><span class="line">    return num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ES6为参数提供了默认值。在定义函数时便初始化了这个参数，以便在参数没有被传递进去时使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function action(num = 200) &#123;</span><br><span class="line">    console.log(num)</span><br><span class="line">&#125;</span><br><span class="line">action(0) // 0</span><br><span class="line">action() //200</span><br><span class="line">action(300) //300</span><br></pre></td></tr></table></figure></p><h3 id="6-展开运算符"><a href="#6-展开运算符" class="headerlink" title="6. 展开运算符"></a><strong>6. 展开运算符</strong></h3><p>可以用来组装数组或者对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//数组</span><br><span class="line">    const color = [&apos;red&apos;, &apos;yellow&apos;]</span><br><span class="line">    const colorful = [...color, &apos;green&apos;, &apos;pink&apos;]</span><br><span class="line">    console.log(colorful) //[red, yellow, green, pink]</span><br><span class="line">    </span><br><span class="line">    //对象</span><br><span class="line">    const alp = &#123; fist: &apos;a&apos;, second: &apos;b&apos;&#125;</span><br><span class="line">    const alphabets = &#123; ...alp, third: &apos;c&apos; &#125;</span><br><span class="line">    console.log(alphabets) //&#123; &quot;fist&quot;: &quot;a&quot;, &quot;second&quot;: &quot;b&quot;, &quot;third&quot;: &quot;c&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有时候我们想获取数组或者对象除了前几项或者除了某几项的其他项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//数组</span><br><span class="line">    const number = [1,2,3,4,5]</span><br><span class="line">    const [first, ...rest] = number</span><br><span class="line">    console.log(rest) //2,3,4,5</span><br><span class="line">    //对象</span><br><span class="line">    const user = &#123;</span><br><span class="line">        username: &apos;lux&apos;,</span><br><span class="line">        gender: &apos;female&apos;,</span><br><span class="line">        age: 19,</span><br><span class="line">        address: &apos;peking&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    const &#123; username, ...rest &#125; = user</span><br><span class="line">    console.log(rest) //&#123;&quot;address&quot;: &quot;peking&quot;, &quot;age&quot;: 19, &quot;gender&quot;: &quot;female&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="7-import和export"><a href="#7-import和export" class="headerlink" title="7. import和export"></a><strong>7. import和export</strong></h3><p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p><p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。<br>使用export命令定义了模块的对外接口，其他 JS 文件就可以通过import命令加载这个模块。</p><h3 id="8-对象字面量-和-类（class"><a href="#8-对象字面量-和-类（class" class="headerlink" title="8. 对象字面量 和 类（class)"></a><strong>8. 对象字面量 和 类（class)</strong></h3><p>其实这两个都是为了使代码更加简洁清晰。</p><ul><li>对象字面量简写</li></ul><p>在对象中，如果属性和值同名时，可以这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// es6</span><br><span class="line">const person = &#123;</span><br><span class="line">  name,</span><br><span class="line">  age,</span><br><span class="line">  getName() &#123; // 只要不使用箭头函数，this就还是我们熟悉的this</span><br><span class="line">    return this.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// es5</span><br><span class="line">var person = &#123;</span><br><span class="line">  name: name,</span><br><span class="line">  age: age,</span><br><span class="line">  getName: function getName() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ul><li>class<br>ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// ES5</span><br><span class="line">// 构造函数</span><br><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 原型方法</span><br><span class="line">Person.prototype.getName = function() &#123;</span><br><span class="line">  return this.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ES6</span><br><span class="line">class Person &#123;</span><br><span class="line">  constructor(name, age) &#123;  // 构造函数</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getName() &#123;  // 原型方法</span><br><span class="line">    return this.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>是不是很简单明了。</p><h3 id="9-Promise"><a href="#9-Promise" class="headerlink" title="9. Promise"></a><strong>9. Promise</strong></h3><blockquote><p>在promise之前代码过多的回调或者嵌套，可读性差、耦合度高、扩展性低。通过Promise机制，扁平化的代码机构，大大提高了代码可读性；用同步编程的方式来编写异步代码，保存线性的代码逻辑，极大的降低了代码耦合性而提高了程序的可扩展性。</p></blockquote><p>其实就是用同步的方式去写异步代码。<br>下面代码创造了一个Promise实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">  // ... some code</span><br><span class="line"></span><br><span class="line">  if (/* 异步操作成功 */)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。resolve即成功时调用，resolve失败时调用。<br>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(function(value) &#123;</span><br><span class="line">  // success</span><br><span class="line">&#125;, function(error) &#123;</span><br><span class="line">  // failure</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>随时补充。。<br>相关链接：</p><ol><li><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">http://es6.ruanyifeng.com/</a></li><li><a href="https://www.cnblogs.com/libin-1/p/6716470.html" target="_blank" rel="noopener">https://www.cnblogs.com/libin-1/p/6716470.html</a></li></ol>]]></content>
      
      <categories>
          
          <category> javascript ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>html,css一些知识点（随时补充）</title>
      <link href="/2018/05/20/HTML+CSS%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2018/05/20/HTML+CSS%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<h3 id="1-html5优点和缺点"><a href="#1-html5优点和缺点" class="headerlink" title="1. html5优点和缺点"></a>1. html5优点和缺点</h3><blockquote><p>   优点：    a、网络标准统一、HTML5本身是由W3C推荐出来的。<br>          b、多设备、跨平台<br>          c、即时更新。<br>          d、提### 高可用性和改进用户的友好体验；<br>          e、有几个新的标签，这将有助于开发人员定义重要的内容；<br>          f、可以给站点带来更多的多媒体元素(视频和音频)；<br>          g、可以很好的替代Flash和Silverlight；<br>          h、涉及到网站的抓取和索引的时候，对于SEO很友好；<br>          i、被大量应用于移动应用程序和游戏。<br>缺点： a、安全：像之前Firefox4的web socket和透明代理的实现存在严重的安全问题，同时web storage、web socket 这样的功能很容易被黑客利用，来盗取用户的信息和资料。<br>          b、完善性：许多特性各浏览器的支持程度也不一样。<br>          c、技术门槛：HTML5简化开发者工作的同时代表了有许多新的属性和API需要开发者学习，像web worker、web socket、web storage 等新特性，后台甚至浏览器原理的知识，机遇的同时也是巨大的挑战<br>          d、性能：某些平台上的引擎问题导致HTML5性能低下。<br>          e、浏览器兼容性：最大缺点，IE9以下浏览器几乎全军覆没。</p><h3 id="2-Doctype作用？严格模式和混杂模式如何区分？有何意义？"><a href="#2-Doctype作用？严格模式和混杂模式如何区分？有何意义？" class="headerlink" title="2. Doctype作用？严格模式和混杂模式如何区分？有何意义？"></a>2. Doctype作用？严格模式和混杂模式如何区分？有何意义？</h3><p> 回答1： （1）、 声明位于文档中的最前面，处于标签之前。告知浏览器的解析器，用什么文档类型 规范来解析这个文档。<br>            （2）、严格模式的排版和JS 运作模式是以该浏览器支持的最高标准运行。<br>            （3）、在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。               （4）、DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。<br>回答2： doctype声明指出阅读程序应该用什么规则集来解释文档中的标记。在Web文档的情况下，“阅读程序”通常是浏览器或者校验器这样的一个程序，“规则”则是W3C所发布的一个文档类型定义（DTD）中包含的规则。<br> (1) 声明位于文档中的最前面的位置，处于标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的HTML 文档。<br>(2)所谓的标准模式是指，浏览器按 W3C 标准解析执行代码；怪异模式则是使用浏览器自己的方式解析执行代码，因为不同浏览器解析执行的方式不一样，所以我们称之为怪异模式。 严格模式是浏览器根据web标准去解析页面，是一种要求严格的DTD，不允许使用任何表现层的语法，如<br>。严格模式的排版和JS 运作模式是以该浏览器支持的最高标准运行混杂模式则是一种向后兼容的解析方法，说的透明点就是可以实现IE5.5以下版本浏览器的渲染模式。<br>(3)浏览器解析时到底使用标准模式还是怪异模式，与你网页中的 DTD 声明直接相关， DTD 声明定义了标准文档的类型（标准模式解析）文档类型，会使浏览器使用相应的方式加载网页并显示，忽略 DTD 声明 ,将使网页进入怪异模式。<br><a id="more"></a></p><h3 id="3-link和-import区别？"><a href="#3-link和-import区别？" class="headerlink" title="3. link和@import区别？"></a>3. link和@import区别？</h3><p>两者都是外部引用CSS的方式，但是存在一定的区别：<br>区别1： link 是 XHTML 标签，除了加载 CSS 外，还可以定义 RSS 等其他事务； @import 属于 CSS 范畴，只能加载 CSS 。<br>区别2： link 引用 CSS 时，在页面载入时同时加载； @import 需要页面网页完全载入以后加载。<br>区别3： link 是 XHTML 标签，无兼容问题； @import 是在 CSS2.1 提出的，低版本的浏览器不支持。<br>区别4： link 支持使用 Javascript 控制 DOM 去改变样式；而 @import 不支持。</p></blockquote><h3 id="4-iframe缺点"><a href="#4-iframe缺点" class="headerlink" title="4. iframe缺点"></a>4. iframe缺点</h3><blockquote><p>1.阻塞主页面的onload<br>2.搜索引擎无法解读这种页面，不利于seo。<br>3.iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。<br>最好办法：js动态给iframe添加src</p></blockquote><h3 id="5-css优先级"><a href="#5-css优先级" class="headerlink" title="5. css优先级"></a>5. css优先级</h3><blockquote><p>在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。<br>作为style属性写在元素内的样式<br>id选择器<br>类选择器<br>标签选择器<br>通配符选择器</p></blockquote><h3 id="6-BFC"><a href="#6-BFC" class="headerlink" title="6. BFC"></a>6. BFC</h3><blockquote><p>(1)、什么是BFC与IFC<br>a、BFC（Block Formatting Context）即“块级格式化上下文”， IFC（Inline Formatting Context）即行内格式化上下文。常规流（也称标准流、普通流）是一个文档在被显示时最常见的布局形态。一个框在常规流中必须属于一个格式化上下文，你可以把BFC想象成一个大箱子，箱子外边的元素将不与箱子内的元素产生作用。<br>b、BFC是W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。当涉及到可视化布局的时候，Block Formatting Context提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。也可以说BFC就是一个作用范围。<br>c、在普通流中的 Box(框) 属于一种 formatting context(格式化上下文) ，类型可以是 block ，或者是 inline ，但不能同时属于这两者。并且， Block boxes(块框) 在 block formatting context(块格式化上下文) 里格式化， Inline boxes(块内框) 则在 Inline Formatting Context(行内格式化上下文) 里格式化。<br>(2)、如何产生BFC<br>当一个HTML元素满足下面条件的任何一点，都可以产生Block Formatting Context：<br>a、float的值不为none<br>b、overflow的值不为visible<br>c、display的值为table-cell, table-caption, inline-block中的任何一个<br>d、position的值不为relative和static<br>CSS3触发BFC方式则可以简单描述为：在元素定位非static，relative的情况下触发，float也是一种定位方式。<br>(3)、BFC的作用与特点<br>a、不和浮动元素重叠，清除外部浮动，阻止浮动元素覆盖<br>如果一个浮动元素后面跟着一个非浮动的元素，那么就会产生一个重叠的现象。常规流（也称标准流、普通流）是一个文档在被显示时最常见的布局形态，当float不为none时，position为absolute、fixed时元素将脱离标准流。</p></blockquote><h3 id="7-webSocket-如何兼容低浏览器？"><a href="#7-webSocket-如何兼容低浏览器？" class="headerlink" title="7. webSocket 如何兼容低浏览器？"></a>7. webSocket 如何兼容低浏览器？</h3><blockquote><p>Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR</p></blockquote><h3 id="8-哪些操作会导致内存泄漏。"><a href="#8-哪些操作会导致内存泄漏。" class="headerlink" title="8. 哪些操作会导致内存泄漏。"></a>8. 哪些操作会导致内存泄漏。</h3><blockquote><p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。<br>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。<br>1.setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。<br>2.闭包<br>3.控制台日志<br>4.循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</p></blockquote><h3 id="9-Node优缺点"><a href="#9-Node优缺点" class="headerlink" title="9. Node优缺点"></a>9. Node优缺点</h3><blockquote><p>优点：<br>1.因为Node是基于<strong>事件驱动和无阻塞</strong>的，所以非常适合处理并发请求，因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。<br>2.与Node代理服务器交互的客户端代码是由javascript语言编写的，因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。<br>缺点：<br>1.Node是一个相对新的开源项目，所以不太稳定，它总是一直在变。<br>2.缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子（第三方库现在已经很丰富了，所以这个缺点可以说不存在了）。</p></blockquote><h3 id="10-懒加载（延迟加载）和异步加载。"><a href="#10-懒加载（延迟加载）和异步加载。" class="headerlink" title="10. 懒加载（延迟加载）和异步加载。"></a>10. 懒加载（延迟加载）和异步加载。</h3><h3 id="11-事件监听"><a href="#11-事件监听" class="headerlink" title="11. 事件监听"></a>11. 事件监听</h3>]]></content>
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ajax回顾总结</title>
      <link href="/2018/05/16/Ajax%E5%92%8C%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
      <url>/2018/05/16/Ajax%E5%92%8C%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>简单的总结下ajax和跨域问题。</p><p>手写原生ajax算是比较高频的面试题了，目的就是看你是否明白其原理。<br>首先是XMLHttpRequest对象，现代浏览器均支持（IE5 和 IE6 使用 ActiveXObject）。它是一个window对象。它的reponseText属性可以获取返回数据。readyState和status属性可以标识返回状态。<br>onreadystatechange是一个事件，或者说一个函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var request = new XMLHttpRequset();</span><br><span class="line">request.onreadystatechange = function () &#123;</span><br><span class="line">if (request.readyState ==4 &amp;&amp; request.status == 200) &#123;</span><br><span class="line">alert(requset.reponseText)//成功，返回reponseText</span><br><span class="line">&#125;else &#123;</span><br><span class="line">alert(requset.status)  //失败，返回错误状态码</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">requset.get(&apos;GET&apos;, url, true) ;//默认为true，可不写。表示异步</span><br><span class="line">requset.send()</span><br></pre></td></tr></table></figure></p><a id="more"></a><ol><li>jsonp跨域。<br>原理：利用script标签可跨域的特性。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=&quot;getPrice()&quot;&gt;点击刷新&lt;/button&gt;</span><br><span class="line">&lt;p id=&quot;test&quot;&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function refreshPrice(data) &#123;</span><br><span class="line">var p = document.getElementById(&apos;test&apos;);</span><br><span class="line">p.innerHTML = &apos;当前价格：&apos; +</span><br><span class="line">data[&apos;0000001&apos;].name +&apos;: &apos; + </span><br><span class="line">data[&apos;0000001&apos;].price + &apos;；&apos; +</span><br><span class="line">data[&apos;1399001&apos;].name + &apos;: &apos; +</span><br><span class="line">data[&apos;1399001&apos;].price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getPrice() &#123;</span><br><span class="line">var script = document.createElement(&apos;script&apos;);</span><br><span class="line">var head = document.getElementsByTagName(&apos;head&apos;)[0];</span><br><span class="line">script.src = &apos;http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice&apos;;</span><br><span class="line">head.appendChild(script)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借用了廖雪峰老师网站里的例子。</p><ol><li>CORS。<br> CORS全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。设置服务端Access-Control-Allow-Origin</li><li>服务器代理。同源域名下设置一个代理服务器来转发。</li><li>window.name</li><li>document.domain</li><li>window.postMessage<br>下面3个网上都有许多介绍。我反正是不怎么了解。。。额。。</li></ol><p>这个是借鉴网上一篇博客的总结，总之具体问题具体对待吧。<br>1.jsonp 需要目标服务器配合一个callback函数。<br>2.window.name+iframe 需要目标服务器响应window.name。<br>3.window.location.hash+iframe 同样需要目标服务器作处理。<br>4.html5的 postMessage+ifrme 这个也是需要目标服务器或者说是目标页面写一个postMessage，主要侧重于前端通讯。<br>5.CORS  需要服务器设置header ：Access-Control-Allow-Origin<br>6.nginx反向代理<br>这个方法一般很少有人提及，但是他可以不用目标服务器配合，不过需要你搭建一个中转nginx服务器，用于转发请求。</p>]]></content>
      
      <categories>
          
          <category> ajax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ajax </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018秋招部部分大厂面试题</title>
      <link href="/2018/05/16/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98%E9%83%A8%E5%88%86%E4%B8%80%E8%A7%88/"/>
      <url>/2018/05/16/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98%E9%83%A8%E5%88%86%E4%B8%80%E8%A7%88/</url>
      <content type="html"><![CDATA[<p>阿里一面（其实一面挺简单的，但发挥不好，面试官希望你会框架。问我react时，我一谦虚说不算很会，就不问我了，然后就挂了）：</p><p>web语义化<br>meta标签作用（页面信息、搜索引擎、不同设备）认识<meta>这篇文章讲得很全面。<br>行内元素、块元素有哪些，布局<br>布局方式<br>三栏布局<br>css选择器优先级<br>http请求过程<br>http2.0了解<br>es2015了解哪些新特性(let/const,promise,class,set/map等忘了说箭头函数)<br>箭头函数和普通函数区别(this指向、不能做构造函数、不能使用arguments等)<br>异步编程(回调函数、监听/订阅、promise、async/await)<br>promise相关，规范、状态<br>百度三面(百度做了一个试题集，真是用心！！！面试感觉还是挺好的，很愉快的面试，但可怜的我并没有收到offer。另外有些面试会考手写代码，从头写到尾，不知道为什么没考我。。。)<br>百度一面：</p><p>自我介绍<br>获取页面上个数top3标签<br>提取url键值对<br>console.log输出加上“hello”<br>linux bash命令cp/rm/mv/cat/ln -s/alias<br>有一个目录很深，如何很快的进入(建立软链接、设置别名？)<br>ajax跨域（cors、反向代理）<br>简述jsonp过程<br>ajax请求过程<br>两栏布局<br>css选择器优先级<br>离线缓存(manifest(貌似废弃了)、service worker(还不成熟))<br>客户端存储方式及异同<br>自定义表单，使各浏览器表现一致<br>百度二面：<br><a id="more"></a><br>自我介绍<br>继承方式（原型链、组合模式、寄生组合式继承）<br>web性能优化、图片优化（雪碧图懒加载）<br>web安全：xss csrf sql注入<br>linux部分知识tail top<br>自定义dialog组件（注意:要用闭包封装模块）<br>nodejs http获取百度页面，把百度改为千百度<br>输入url过程<br>单纯的聊天(不记入面试)：看一个页面布局，说出布局想法<br>百度三面(总监面)：</p><p>自我介绍<br>某个取值范围的随机数生成<br>nodejs优点<br>ajax请求过程<br>项目相关<br>谈人生规划<br>网易一面：</p><p>写一个继承，解释原型链<br>css规范化<br>闭包应用、模块<br>mvvm相关<br>知道哪些设计模式<br>两列布局<br>跨域方法<br>flex布局属性<br>事件流的三个阶段，哪些事件不能冒泡<br>迅雷一面(不得不说，迅雷笔试很有水平)：</p><p>项目相关<br>unicode与utf-8字符编码方式关系<br>nodejs处理请求过程<br>require(‘child_process’).fork和linux fork区别<br>美团一面：</p><p>webpack原理<br>闭包自由发挥<br>react优势(组件化、虚拟dom)<br>怎么设计好的组件<br>项目相关<br>反转链表<br>https与http区别<br>git命令了解哪些<br>github开源做过哪些，贡献过什么，pr过吗</p>]]></content>
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于闭包的理解</title>
      <link href="/2018/05/15/%E5%85%B3%E4%BA%8E%E9%97%AD%E5%8C%85%E7%9A%84%E6%80%BB%E7%BB%93/"/>
      <url>/2018/05/15/%E5%85%B3%E4%BA%8E%E9%97%AD%E5%8C%85%E7%9A%84%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p><strong>如何理解闭包</strong><br>闭包在以前几乎是面试必考的问题，往往会跟作用域，垃圾回收机制一同考查。</p><ol><li>首先要知道闭包就是一个函数，不是其它的东西。</li><li>js的函数就像一个黑屋子，函数可以访问到外部的信息，但是外部却无法访问到其内部。</li><li>函数执行的时候会先创建一个属于该函数的上下文执行环境，当函数执行完毕之后，这个上下文执行环境就会被回收。</li><li>但是当闭包出现时，这个环境就不会被回收了。因为闭包函数引用了不是它内部的作用域也不是全局作用域的局部变量。（父级或祖父级等）</li></ol><a id="more"></a><p><strong>举个例子</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function outer () &#123;</span><br><span class="line">var a = 1;</span><br><span class="line">function inner () &#123;</span><br><span class="line">a++;</span><br><span class="line">console.log(a)</span><br><span class="line">&#125;</span><br><span class="line">return inner;</span><br><span class="line">&#125;</span><br><span class="line">var fn = outer();</span><br><span class="line">fn(); //2</span><br><span class="line">fn(); //3</span><br></pre></td></tr></table></figure></p><p>inner函数引用了外部函数的变量，所以inner函数就是一个闭包。因为局部变量a一直被引用，所以不会被回收，而是一直存在的。</p><p><strong>另外一道面试题</strong></p><p>点击Li,打印相应的index。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var lis = document.getElementsByTagName(&apos;li&apos;);</span><br><span class="line">for (var i = 0; i &lt; lis.length; i++) &#123;</span><br><span class="line">lis[i].onclick = function () &#123;</span><br><span class="line">console.log(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假如lis.length为4，这样写无论点击哪个li，都会打印4。这是为什么呢，原因是onclick执行的时候for循环已经结束了。此时的i=4。我们如何以闭包来解决这个问题呢？</p><p>很容易，一个函数中嵌套另一个函数，并讲这个函数return出去，并保存到一个变量之中，那么就创建了一个闭包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var lis = document.getElementsByTagName(&apos;li&apos;);</span><br><span class="line">for (var i = 0; i &lt; lis.length; i++) &#123;</span><br><span class="line">lis[i].onclick = a(i)</span><br><span class="line">&#125;</span><br><span class="line">function a (i) &#123;</span><br><span class="line">return function () &#123;</span><br><span class="line">console.log(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以达到目的了。</p><p>也可以这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var lis = document.getElementsByTagName(&apos;li&apos;);</span><br><span class="line">for (var i = 0; i &lt; lis.length; i++) &#123;</span><br><span class="line">lis[i].onclick = (function (i) &#123;</span><br><span class="line">return function () &#123;</span><br><span class="line">console.log(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将函数包含在一个括号内，就创建了一个闭包环境，从而一直保存变量。后面的一个括号（i）表示自执行。</p><p>闭包的问题通常与许多知识点相结合才能理解。慢慢学吧！</p>]]></content>
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闭包 js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于区块链</title>
      <link href="/2018/01/14/%E5%85%B3%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
      <url>/2018/01/14/%E5%85%B3%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
      <content type="html"><![CDATA[<p>本文转载自知乎@maxdeath<br>首先要搞清一个问题——比特币是区块链，但是区块链并不是比特币。<br>于是，在区块链的这个问题回答里，提到“矿工”，“挖矿”，“最长链”，“分叉”等等词的，其实都不准确。<br>写一点上个月讲课的内容——个人觉得大部分的回答，包括google搜出来的或者wiki的，都不能很好地解释区块链是个什么东西。因为讲比特币的人很多，懂比特币的人也很多，但是具体到区块链，现在并没有一个很清楚的定义说什么是区块链，基本上所有的介绍里都是这样的：<br>比特币——〉区块链是比特币的底层技术。<br>或者<br>比特币——〉比特币是一种区块链。<br>具体到什么是区块链的问题，目前没有看到很好的定义和介绍，更多的是大而化之地讲区块链的意义在哪里的空泛文章，要不然就是一水的矿工和挖矿。所以我来从纯理论角度说一下我个人对区块链的定义：<br>1，区块链是一个放在非安全环境中的分布式数据库（系统）。<br>2，区块链采用密码学的方法来保证已有数据不可能被篡改。<br>3，区块链采用共识算法来对于新增数据达成共识。<br>具有以上三个性质的系统，就是区块链。<br><a id="more"></a></p><p>1，区块链是一个放在非安全环境中的分布式数据库（系统）。<br>这里的要点有两个：（1）分布式，（2）非安全环境。<br>首先，这是一个分布式的，去中心化的系统。所以，有一个中心服务器或者节点的，不是区块链。节点都是安全的，无恶意的，那这不是区块链。同理，从应用的角度讲，如果你的应用必须要使用中心节点（例如要用超级计算机做深度学习）或者没必要考虑节点不安全的情况（例如某个安全的工厂里的传感器），那么并不需要考虑区块链技术。<br>至于后面的词“数据库”，目前大部分成熟的区块链都是数据库，例如比特币就是一个分布式账本，而账本其实就是数据。然后，根据数据的格式，又可以分三种——1，数据是完全不相关的，只是达成的共识，没有有效无效之分；2，数据有某些逻辑结构，例如账本中，一笔交易实际上除了金额，还有输入和输出，连接到之前的交易，这些数据需要通过逻辑验证（例如交易中，节点需要验证输入的交易是否有效）；3，数据拥有图灵完备的逻辑，而验证的时候需要通过节点使用算力运算，每笔交易可以有不同的输出和状态，每个节点要做的不仅仅是验证交易的真实性和输入的正确性，还要根据交易里的逻辑读入数值，进行验算然后再验证结果。<br>比特币的系统就是第二种，又叫分布式账本；以太坊是第三种。第三种可以支持智能合约。<br>用比特币举例的话，1，它是一个完全去中心化的系统，2，它放在一个非安全的环境，它并不要求所有使用比特币的人都没有恶意。</p><p>2，区块链采用密码学的方法来保证已有数据不可能被篡改。<br>这个是误解最多的部分，因为很多人一提到区块链就只觉得是这个。诚然，这部分很重要，而且确实区块链也因此得名，但这只是区块链的定义的一部分。<br>这个部分的两个核心要点是：（1）密码学哈希函数，（2）非对称加密。<br>两个都是密码学的基础概念，网上都有非常清晰的定义，我只简单说下：<br>（密码学）哈希函数：一个函数Y=H(X)，有如下性质：1，有X可以很容易算出Y；2，有Y不可能算出X；3，有Y不可能找到另一个X’使得H(X’)=Y；3.5，如果X和X’相差很小，H(X)和H(X’)则完全不相关。<br>这东西主要用于验证信息完整性——在一个信息后面放上这个信息的哈希值，这个值很小，例如256bit，而且计算方便。收到信息之后收信人再算一遍哈希值，对比两者就知道这条信息是否被篡改过了。如果被篡改过，哪怕只有一bit，整个哈希值也会截然不同。而根据哈希函数的性质，没有人能够伪造出另一个消息具有同样的哈希值，也就是说篡改过的数据完全不可能通过哈希校验。<br>非对称加密：这东西很好理解——对称加密就是有个密钥，可以理解成保险箱钥匙，你把消息加密变成密文，没有人能看懂这是啥，然后同一把钥匙解密成原来的消息。<br>非对称加密就是有两把钥匙，一把叫公钥，一把叫私钥，用其中一把加密的话，只能用另一把解密，反之亦然。另一个重要的性质是，给你密文，明文和其中一把钥匙，你还是解不出来另一把钥匙是啥。原理基本上是基于一些困难数学问题，例如因数分解和离散对数，常用的有RSA，Diffie-Hellman和ECC（椭圆曲线），比特币用的是椭圆曲线。<br>非对称加密除了和对称加密一样用于信息加密之外，还有另一个用途，就是身份验证。因为通常情况我们假设一对公私钥，公钥是公开的，而私钥只有本人有，于是一个人如果有对应的私钥，我们就可以认定他是本人。其中一个重要的应用就是数字签名——某个消息后面，发信人对这个消息做哈希运算，然后用私钥加密。接着收信人首先对消息进行哈希运算，接着用相应的公钥解密数字签名，再对比两个哈希值，如果相同，就代表这个消息是本人发出的而且没有被篡改过。</p><p>以上是基础知识，至于区块链怎么实现的，很简单：<br>交易（数据）写在区块里。<br>第一个区块叫创世区块，写啥都行。<br>从第二个区块开始，每个区块的第一部分有前一区块的哈希值。此外，区块里的每一笔交易（数据），都有发起人的数字签名来保证真实性和合法性。于是，先前区块里的任何数据都不可被篡改，原因见上。</p><p>到这为止有人可能会问：为什么要弄个链啊？直接所有数据加个哈希值不就行了？<br>因为——这个数据库并不是静止的啊。<br>数据库的数据是会增加的，而每次增加的数据，就是一个区块，于是这些生成时间不同的区块，就以这种形式链在一起了。<br>至于如何增加区块，就涉及到第三个部分——共识算法。</p><p>3，区块链采用共识算法来对于新增数据达成共识。</p><p>共识算法的目的，就是让所有节点对于新增区块达成共识，也就是说，所有人都要认可新增的区块。对于有中心的系统，这事很简单，中心说什么大家同意就好了，但是放到去中心化系统里，尤其是当有些节点有恶意的时候，这东西非常复杂，计算机科学里有个相应的问题，叫做“拜占庭将军问题”或者“拜占庭容错”（BFT）。<br>有很多用Lamport给出的那个例子来讲BFT的东西，我在这里换一个角度。<br>Lamport大神当年提出这个问题的时候在斯坦福研究中心给NASA做项目，他提出这个问题的原因并不是考虑类似比特币的应用场景（整个互联网成千上万个用户），而是考虑特殊背景下的一个简单的系统——<br>航天飞机的控制系统。<br>如果有航空背景的同学可能知道，飞机有三套独立的控制系统，为什么呢？因为任何系统都不可能完全不出故障，就算飞机控制系统的故障率已经极低了，还是有飞到一半这东西坏了的可能。于是我们可以弄两套独立的系统，同时坏掉的几率就会大大降低。<br>可是两套独立的系统还是不足以容下一个系统的错误——一架飞机迎面飞来，两套系统一个说要躲，一个说不躲，那到底是躲还是不躲呢？所以我们需要三台独立的系统，这样，如果有一个系统有故障了，还有两台能正常工作，能少数服从多数给出正确的结果。学过纠错码的同学对这个应该不陌生，这个系统的输出之间的汉明间距是3，所以可以纠正一位的错误。<br>然而，对于航天飞机，在冷战的背景下，万一某个系统不是坏掉了，而是被敌人控制了呢？三套系统还够吗？<br>答案是否定的，因为不同于单纯只是坏掉的节点，恶意节点可以做一些别的事来阻止整个系统达成共识。<br>这个部分略复杂要讲的话要单开一帖，所以我们只说最简单的情况（无签名同步系统）。<br>我们管三个系统叫ABC，正常工作流程是三个人每次得出结果就互相告诉一下，然后每个人选多数人同意的结果。这是个没有中央节点的分布式系统，也就是说三人不能聚在一起开个会啥的，仨人只能两两通信。这个时候，假设C有恶意，它的目标是破坏这个系统。于是，假设正确的读数是1，A和B都得出了1这个结果，这个时候C这个小婊砸告诉A说“我的结果是0，B也觉得是0”，同时打个电话跟B说“哎我觉得是0，A也这么说”，于是A和B就懵逼了。假设你是A，你听到了两个不同版本的B的答案，B说自己选了1，C说B选了0，可是A这个时候没法知道B和C谁才是那个骗了自己的小婊砸，因为如果B真的告诉A选了1然后告诉C是0，他听到的结果和现在是一模一样的。<br>于是结论是，拜占庭容错，也就是需要容下一个恶意系统而非错误系统，需要4个独立系统。<br>（当然，签名可以解决这个问题，但是这只是同步系统的情况，在异步系统里这问题会变得更加复杂，原因是正常节点的回答有延迟，而恶意节点可以不回复，所以，正常节点一方面要等另一个节点的回复，但是它又不知道对方会不会回复因为对方有可能会有恶意，而在收到回复之前，它完全没法判断对方是正常节点还是恶意节点，这个问题叫异步BFT，也是BFT的最复杂的情况，这里不再做更多的解释，下文提到的BFT算法，其实都是异步BFT的算法）<br>Lamport提出这个问题之后，有无数的算法被提出来，统称BFT（拜占庭容错）算法，其中最有代表性的叫PBFT，然后由于最近区块链的热度，无数针对区块链应用场景优化过的BFT算法也涌现出来，但是一个重要的问题是，所有目前的BFT算法，都只能应用在小型网络里。原因很简单——因为BFT这个问题是设计给类似于航天飞机控制系统这样的场景的，早期的算法考虑的也主要是这种场景。PBFT论文里考虑的就是一个5个节点的系统。就算算上新提出的BFT算法，也最多应用在不超过100个节点的网络里。<br>这个问题被搁置了很久，直到比特币的诞生——中本聪从某种意义上简化了这个问题，在比特币中，同样是共识问题，中本聪引入了一个重要的假设——奖励，他之所以能这样做的原因是，他考虑的是一个数字货币，也就是说共识这个东西是有价值的。<br>于是在这样的系统上，他提出了工作证明机制。<br>所有挖矿，矿工，最长链，分叉等等等等，都可以归结为一句话：<br>说话是要有代价的，说真话是有好处的，说假话是要扣钱的……<br>这就是目前两类共识算法的核心区别：<br>BFT共识模型：恶意节点可以干任何事。<br>比特币共识模型：模型中有公认的“价值”，每个节点说话都需要一定代价，诚实节点会受到奖励，而恶意节点由于只付出代价而收不到奖励，变相受到了惩罚。<br>也就是说，BFT共识模型其实涵盖了比特币共识模型的场景，比特币共识其实放宽了BFT共识模型的限制。<br>比特币共识对于BFT的优势在于，由于给恶意节点的能力做了限制，恶意节点所能造成的破坏大大降低了，尤其是对于异步系统——BFT共识里恶意节点可以一直拒绝相应而诚实节点还需要一直等它（因为不知道它是不是恶意的），而对于比特币共识，随你便，你不响应就没有奖励可拿。于是，比特币共识算法可以应用于成千上万个节点，而且，任何人随时都可以加入，不需要预先在网络里注册自己的身份（而BFT算法里，网络中节点的数量和身份都必须是已知的）。<br>但比特币共识的缺陷在于，首先，得有个有价值的东西，也就是说放在比特币里这东西还行，以太坊的话现在可能也凑合，但是其他数字货币嘛……BFT共识有个严格的限定，就是恶意节点不能超过总数的1/3，然而其实比特币共识没有这样的限制，唯一的限制就是假定大部分节点都是理性的，是逐利的，也就是会采用最佳的策略来赚取最大的价值。所以，严格来说，自私挖矿这种行为在比特币共识里是允许的，而多数攻击，其实也算不上一种攻击，因为这些都没有突破比特币共识的框架——如果这个价值无限大，比特币共识是非常可靠的。然而这并不是事实，因为并不是每个虚拟货币都和比特币一样值钱，而在价值不高的情况下，比特币共识的前提就站不住脚了——当损失可能是几千上万块钱的时候，假定每个人都是理性的是合理，但是如果损失就几分钱这个假设就相当扯淡了，事实上也发生过一个比特币矿池跑到另一个货币恶意挖矿搞垮对手的情况。<br>此外，比特币共识是最长链共识，也就是说最长链–&gt;大多数–&gt;理性，于是分叉是允许的。于是导致了一些附带的问题，例如，如果网络有延迟，你怎么知道你手里那条链是整个网络里当前的最长链呢？于是，如果需要传输的数据多，那么延迟加大。延迟加大，那么越多的人手里的链并不是全网络的最长链。于是，全网络的最长链，就没法代表大多数。这就打破了比特币共识的根本，这也是为什么比特币区块频率是10分钟一块的原因。比特币目前有个著名的7币交易每秒的上限，而现在扩容闹得很厉害，以太坊的交易格式不同，也用了新的工作证明，想要改成权益证明，但这些都不本质。真正本质的是，在目前的网络条件下，如果适用全网的话，比特币共识的交易量基本上超不过100笔交易每秒这个量级。<br>上面这几段有可能太深了，简单来说，BFT共识和比特币共识的区别可以这么理解：</p><p>BFT共识：来，大家开个会讨论一下集思广益啊，讨论出大家都满意的结果为止。<br>问题：开会的效率大家都懂，人越多越不容易出结果。只能用于少数节点，用于上千个节点的话……大家想象一下一天开一次人大的场景。</p><p>比特币共识：你的诗念得不错，组织已经决定了，今天就你来当领导了，做得好有奖，做不好扣钱。<br>问题：奖励几千块钱还好，奖励几分钱谁好好干？</p><p>而区块链也就因此被分成了泾渭分明的两类，很多人都听过什么公有链私有链联盟链，但是，如果你们以为这是根据应用区分的就大错特错，其实，这两种区块链最本质的区别，还是因为共识模型或者说算法不同——BFT算法没法应用于大量节点，所以用BFT算法的就没法做公有链。而比特币共识得有个价值体系，这东西去做私有链联盟链就很不靠谱，因为一个单纯逐利的人的假设还算靠谱，但是如果对象是公司的话，公司的利益就太复杂了，不能简单认为他们只追逐区块链上那点价值。<br>1，公有链，以比特币，以太坊和所有虚拟货币为代表，都采用比特币共识，共识算法基本上都采用工作证明机制，也就是挖矿那些，这种机制其他回答里已经讲得够清楚了，就略过。工作证明一切都好，除了费电……费多少电呢？比特币的话，差不多和一个百万人级别的城市那么多。此外以太坊的创始人特别喜欢权益证明，似乎很快要小范围投入使用（100个区块里一个用权益证明）。但是目前为止，大家对这东西的可靠性还持观望态度。<br>2，私有链和联盟链。以IBM的hyperledger-fabric，以及一大堆其他的类似于tendermint，甚至R3 corda和ripple为代表，都用BFT共识。其实这方面的应用已经很多了，问题是，1，目前基本上所有应用给人的感觉都还是为了做区块链而区块链，真的觉得这东西好到不可或缺的应用还基本没有。2，由于为了区块链而区块链，其实很多场景的安全性和可靠性还值得怀疑，这点经常被被公有链的支持者诟病。</p><p>嘛，以上就是个人定义的区块链了，顺带概述一下现在区块链领域的发展。<br>之所以写这个帖子，就是因为发现明明是问区块链的问题，所有人都在讲比特币，都在讲挖矿，都在讲工作证明……工作证明不能说过时，也的确是现在公有链唯一可靠的共识算法，但是这东西确实是业界除了比特币死忠之外谁都不想要的东西好吗……</p><p>作者：maxdeath<br>链接：<a href="https://www.zhihu.com/question/37290469/answer/167477833" target="_blank" rel="noopener">https://www.zhihu.com/question/37290469/answer/167477833</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      <categories>
          
          <category> 科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>随便写写</title>
      <link href="/2018/01/12/%E9%9A%8F%E4%BE%BF%E5%86%99%E5%86%99/"/>
      <url>/2018/01/12/%E9%9A%8F%E4%BE%BF%E5%86%99%E5%86%99/</url>
      <content type="html"><![CDATA[<p>给父亲的一封信：<br>很早就想写点什么了，往往都说在刚提笔的时候被各种信息阻挠，而后就不了了之。现在，在这个宁静的时候，终于能够认真的写出点东西了，想多少写多少吧。<br>为什么说是给爸爸的一封信呢，因为在我看来，父爱如山，母爱如海。从小到大跟在母亲的身边比较多，母亲是一位小学老师，懂钢琴、琵琶，会书法，画画。能歌善舞，是学校的音乐老师也是舞蹈队的领队。她说话柔声细语做事慢条斯理。正如我所说，她给了我一切呵护和包容，仿佛大海一样，即使我乱发脾气扔块大石头，也不会起任何涟漪。父亲呢，他在我心目里像山峰一样挺拔，从我记事起，他就在一个镇里的中学当校长。打小开始他就是我的骄傲，风雨下的屋檐，我的保护伞。<a id="more"></a>我作为一校之长的儿子，心里当然美滋滋。在成长的路上或多或少都有高人一等的感觉。在我心里，父亲是无所不能的。直到，父亲的鬓角越来越白，脸上的皱纹越来越多。我才意识到，父亲也有老的一天，而我。确还像个孩子一样。一如从前。<br>今年是毕业的第四年了。也是在魔都的第四年。<br>我已经不记得上一次如这次一样认真学习，思考，是什么时候了。初中的我只会学习，高中的我被形形色色的诱惑吸引，成绩一落千丈。第一年高考失利，刚刚二本线。复读了一年也仅仅是差7分到一本。我至今还清楚记得成绩出来的那一刻，父亲失落和关切的眼神交杂在一起。如今想来五味杂陈。我深深的知道，父亲比母亲，比任何人都望子成龙。但是他只是偶尔在醉酒的时候才会拉着我说出来。在平时，给我说的最多的就是“多锻炼身体啊!没关系，你做什么我都支持！大胆去干是咯！不要担心家里！我说多你又嫌烦，锻炼，学习就行了！家里是你坚实的后盾！”<br>父亲说了四年，而我，在这四年里。一事无成。<br>我至今都不确定在大学毕业后，拒绝家里安排的一份国企的工作，只身来到上海闯荡对不对。俗话说，养儿防老，又说，家里不希望你大富大贵，只希望你健健康康。我在离开家这么远 的地方，我又能为父母做到什么呢。我又做到了什么呢。<br>回顾这四年，终于在此刻认真的思考自己，剖析自己，总结自己。<br>大学四年，过的疯狂潇洒，把积压在身体里十几年的爱玩的天性放出来了，如放虎归山，再也无法回笼。毕业的时候，以为自己还不错，凭借这自学和黑作坊培训的一点点知识，只身跑到上海，梦想着，憧憬着作为一名合格的IT工作者，一名前端工程师，然后再一路走下去，创业，当CEO。当时很自信的选择这条路，因为自己是班里第一个走前端，当时还叫网页设计这条路的，自以为走在大部分人的前面。当时真的是初生牛犊不怕虎，下着大雨提着被子背着行李自己在上海找房子，面试。那时的我比现在坚强。<br>第一份工作很平淡，在一家黑榜top100里的小公司混日子。终于在几个月后受不了老板的压迫和神经质，跟同事们纷纷辞职。那段时间，在那个狭小，黑暗，薄木板床，十几个人合租的却又很昂贵的隔断间里。胡思乱想，杳无头绪，在准备了一段时间开始第二次面试的时候，才知道技术的道路上不是那么简单。在面了三四家都没音讯，终于在5173二面被刷的时候，崩溃了，想家了。曾经满心抱负，自信的我终于知道自己所学的那些只是芝麻粒。坐在公司外的草坪上，我给爸爸打了电话，终于哭了出来。我还清清楚楚记得哪时候，爸爸说，儿子你很棒，是爸爸没用。没关系，安安心心的再找就是。我后来才知道在平淡的语气下，爸爸是多么的焦急和担心。儿子慌了、乱了、哭了，爸爸能慌吗，能乱吗，能哭吗。爸爸只能把所有的焦虑，心疼放在心里。嘴上却一刻不停的在安慰，在打趣逗我开心。之后才知道它们差点没连夜打车来上海看我。经历此次风波之后，我终于面上了一家大型公司，沪江网。父母也很欣慰。自己也很高兴，以为终于走向正轨，殊不知，接下来发生的事情才是这四年的始端，也是我如今这样子的初因。<br>由于事先准备的充分，面试的时候问题都答的上来，面试官也就是我的师傅也很看好我。但是，在接下来的工作中，因为没有经验，上手就是做专题，做特效。因为公司要求很严格，流程也很紧张。懵懂的我就这样在第一天就上手做项目，没人指导，我可是新人啊！第一天，我甚至连一个样式都写不好。在惶惶中，我仿佛听到了身后的人在议论，这人不行啊，啥都不会，怎么进来的。终于，第一天，在领导质疑的眼光中灰溜溜的下了班。晚上回去之后加紧时间学习，看w3cschool教程，看实例，可是时间有限，再努力学习的进程都赶不上公司对技术的要求。第二天，屁股还没热就来了新的专题项目。要求我独立完成，满屏的设计图充满了特效和复杂的样式，拜托我还是个切图仔好么。不出所料，在规定的时间没有完成，在加上臃肿的代码，基本上算失败了。领导没说什么，把我的东西交给了别人做了。但是我知道下场一定不好。我延误了流程，不是一个合格的员工。我害怕了，心慌了。在公司里，我是来的最早的一个，却是最安静的一个，我不敢跟同事们聊天，因为我是最菜的那个。他们一定在背后偷偷嘲笑我呢。就是在这样紧张的日子中，我渐渐的熟悉了流程，写的代码也逐渐熟练起来，3天的专题期限我甚至一天就能完成。当我认为我可以逐渐融入公司的时候，一件意想不到的事情发生了。一次上线的报名界面是我做的，但是由于疏忽我没有看清需求，少了一个弹窗效果。在上线的时候才被发现，这可以算是个大事故。在下班的时候，领导狠批了我，紧急撤下页面交给我和后台去加班修改，此刻，我害怕了，无助了。我选择了，逃避！我说我不会改。然后说家里还有事需要紧急回去，领导没说什么。我此刻只想逃离这个地方，回到那间隔断间小屋，此刻黑暗狭窄的小房间却是我最放松，最安全的地方。一旦逃避成瘾，就犹如惯性一般，再也不容易收回来。换句话说，我成了一个惯性逃避责任的人。<br>接下来的日子依旧很紧张，直到有一天，部门经理找了我，大概意思就是你在上个月出出了重大事故，加上你的技术并不娴熟，流程跟不上公司的节奏，有问题不去交流。希望我另谋高就。拜托我可是刚刚走上正轨，最近的专题写的一个比一个快好么。于是乎，我被开了。离职的时候拿着离职单去找各个单位的主管签字的时候，看着他们一个个死鱼脸。都没有平时的笑容。我仿佛被千万种鄙视的眼光万箭穿心。<br>离职的我，并没有告诉家人，依旧给他们说，我还在正常上班，一切都好。此时的我，不会在哭哭啼啼的找爸妈哭诉了。因为一颗逃避的心已经被泥流包裹，躲在里面战战栗栗，在那一小片心房里，却是给我前所未有的安全感。<br>于是，我逃避了，蛰居了，我对工作没了兴趣，对代码没了兴趣。我躲在出租屋里，白天睡觉晚上看剧，我不想去想工作的事情，甚至吃了上顿都不想着下顿，房租没钱厚着脸问家里要。就这样麻木的过了很久。朋友，同学都认为我是懒，是的，我是懒惰了。我没有走出去，我混吃等死，我堕落了。<br>直到有一天，这种日子因为我的“心脏病”事件达到了巅峰。因为我连续的睡在地上，饮食不规律，日出而息，日落而作，我隐隐的有种不舒服的感觉，说不清哪里不舒服。在一次通宵上了网回来的时候，我突然觉得屋子很闷，喘不上气，同时明显感觉到了心跳加快。我想，完了，我莫不是得了心脏病。越想越怕，越怕越慌！我冲进洗手间用凉水去冲脸，并没有作用！同时我的手脚发抖，皮肤发麻，站立不稳，感觉随时都要晕倒。我感紧让我的室友小司打电话叫120，我说我不行了，心脏难受，感觉要死了。这种濒死感，没体验过的真心不知道其中滋味，还不如一下子昏过去来的痛快。120说医院很近让我们打车去，在医院，我进了ICU，医生问我症状，我就说心脏不舒服，抽血做了检查，折腾了半宿，我就是没有晕倒，一直在那失神一样来回踱步。害怕，紧张，脑子里一片空白，我甚至都想着写遗书了！因为我觉得我时刻都会死掉！到了夜晚3点多的时候，医生安慰我说啥事没有，就是紧张的，我不相信，拉着医生说给我吊水，给我扎针，什么都行，我很不舒服。医生没理我，忙别的去了。<br>现在想想真的是可笑，当时的医生应该是知道我这是焦虑症。暗地里说不定还在笑话我呢。这个不是器质上问题，就是情绪，神经的问题。具体导因因人而异。很难查到源头。接下来的一个礼拜我得了感冒（因为那晚没穿外套就去医院了），口鼻窜血，瘦了一圈，胡子邋遢。我上网查了很多资料知道这个症状就是典型的急性焦虑症发作。接下来的一年我都活的很累，时常被这种莫名其妙的症状困扰，睡着睡着就憋醒了，吃着吃着饭就慌了起来。最严重的一次是我走着路就感觉天昏地转，又是一次严重的濒死感，我记得那时候是随便拨了一个号码过去找人家聊天，希望能缓解症状。<br>现在我已经克服了焦虑症，其中艰辛自不必说，大概花了2年了吧。这2年我的学习效率，工作效率，相比刚毕业的那种劲头，地下天上。最主要是，我的逃避心态一直还在，也许真的是惯性的原因吧。<br>此刻我认真的回顾这四年，剖析自己，导致如今的状态，还是怪我自己心理素质不够强大，不敢担负责任，害怕承担后果，习惯性逃避。我想这也是跟我从小到大生活的环境有关吧。对于别人而言，面试和工作的失败，分析自己，抓紧准备，继续面试，继续工作。而对我而言，面试失败，哭。工作失败，逃避。如果当时我勇敢一点，脸皮厚一点，克服过去的话，我会更加爱上编码，更加爱我的工作，我活的一定比现在好。可是生活没有如果。逝去的青春也不会回来。<br>2017年，我做的最勇敢的，也是最成功的一件事，就是追到了我的现女友，我的大学暗恋4年的女神。我仅仅只是鼓起了一点勇气去追，仅仅只是一点点勇气，我的生活就发生了天翻覆地的变化。我们在一起245天了，没吵过架，我很爱她。<br>2018年，我27了！我会以全新的心态去面对一切，努力学习，工作。去弥补我失去的时间，去担负起一个男人的责任，去勇敢面对任何事情。懂得道理是开始，执行和坚持才是关键。我感觉我成长了一点，虽然起步比较晚，但是还不迟，不是么。<br>我不希望，在未来父母需要我的时候，我却什么都不能给他们。我要让自己的努力赶得上父母老去的速度。<br>就写到这里吧，马上要去接女朋友了。一切安好。 </p>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理情感 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一款Markdown编辑器</title>
      <link href="/2018/01/12/%E6%AC%A2%E8%BF%8E%E4%BD%BF%E7%94%A8%20Cmd%20Markdown%20%E7%BC%96%E8%BE%91%E9%98%85%E8%AF%BB%E5%99%A8/"/>
      <url>/2018/01/12/%E6%AC%A2%E8%BF%8E%E4%BD%BF%E7%94%A8%20Cmd%20Markdown%20%E7%BC%96%E8%BE%91%E9%98%85%E8%AF%BB%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，<strong>Cmd Markdown</strong> 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：</p><blockquote><ul><li>整理知识，学习笔记</li><li>发布日记，杂文，所见所想</li><li>撰写发布技术文稿（代码支持）</li><li>撰写发布学术论文（LaTeX 公式支持）</li></ul></blockquote><p><img src="https://www.zybuluo.com/static/img/logo.png" alt="cmd-markdown-logo"><br><a id="more"></a><br>除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：</p><h3 id="Windows-Mac-Linux-全平台客户端"><a href="#Windows-Mac-Linux-全平台客户端" class="headerlink" title="Windows/Mac/Linux 全平台客户端"></a><a href="https://www.zybuluo.com/cmd/" target="_blank" rel="noopener">Windows/Mac/Linux 全平台客户端</a></h3><blockquote><p>请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 <i class="icon-file"></i> <strong>新文稿</strong> 或者使用快捷键 <code>Ctrl+Alt+N</code>。</p></blockquote><hr><h2 id="什么是-Markdown"><a href="#什么是-Markdown" class="headerlink" title="什么是 Markdown"></a>什么是 Markdown</h2><p>Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，<strong>粗体</strong> 或者 <em>斜体</em> 某些文字，更棒的是，它还可以</p><h3 id="1-制作一份待办事宜-Todo-列表"><a href="#1-制作一份待办事宜-Todo-列表" class="headerlink" title="1. 制作一份待办事宜 Todo 列表"></a>1. 制作一份待办事宜 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#13-待办事宜-todo-列表" target="_blank" rel="noopener">Todo 列表</a></h3><ul><li style="list-style: none"><input type="checkbox"> 支持以 PDF 格式导出文稿</li><li style="list-style: none"><input type="checkbox"> 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li><li style="list-style: none"><input type="checkbox" checked> 新增 Todo 列表功能</li><li style="list-style: none"><input type="checkbox" checked> 修复 LaTex 公式渲染问题</li><li style="list-style: none"><input type="checkbox" checked> 新增 LaTex 公式编号功能</li></ul><h3 id="2-书写一个质能守恒公式-LaTeX"><a href="#2-书写一个质能守恒公式-LaTeX" class="headerlink" title="2. 书写一个质能守恒公式[^LaTeX]"></a>2. 书写一个质能守恒公式[^LaTeX]</h3><p>$$E=mc^2$$</p><h3 id="3-高亮一段代码-code"><a href="#3-高亮一段代码-code" class="headerlink" title="3. 高亮一段代码[^code]"></a>3. 高亮一段代码[^code]</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># A comment</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'hello world'</span></span><br></pre></td></tr></table></figure><h3 id="4-高效绘制-流程图"><a href="#4-高效绘制-流程图" class="headerlink" title="4. 高效绘制 流程图"></a>4. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#7-流程图" target="_blank" rel="noopener">流程图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start</span><br><span class="line">op=&gt;operation: Your Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><h3 id="5-高效绘制-序列图"><a href="#5-高效绘制-序列图" class="headerlink" title="5. 高效绘制 序列图"></a>5. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#8-序列图" target="_blank" rel="noopener">序列图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure><h3 id="6-高效绘制-甘特图"><a href="#6-高效绘制-甘特图" class="headerlink" title="6. 高效绘制 甘特图"></a>6. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#9-甘特图" target="_blank" rel="noopener">甘特图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">title 项目开发流程</span><br><span class="line">section 项目确定</span><br><span class="line">    需求分析       :a1, 2016-06-22, 3d</span><br><span class="line">    可行性报告     :after a1, 5d</span><br><span class="line">    概念验证       : 5d</span><br><span class="line">section 项目实施</span><br><span class="line">    概要设计      :2016-07-05  , 5d</span><br><span class="line">    详细设计      :2016-07-08, 10d</span><br><span class="line">    编码          :2016-07-15, 10d</span><br><span class="line">    测试          :2016-07-22, 5d</span><br><span class="line">section 发布验收</span><br><span class="line">    发布: 2d</span><br><span class="line">    验收: 3d</span><br></pre></td></tr></table></figure><h3 id="7-绘制表格"><a href="#7-绘制表格" class="headerlink" title="7. 绘制表格"></a>7. 绘制表格</h3><table><thead><tr><th>项目</th><th style="text-align:right">价格</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td>计算机</td><td style="text-align:right">\$1600</td><td style="text-align:center">5</td></tr><tr><td>手机</td><td style="text-align:right">\$12</td><td style="text-align:center">12</td></tr><tr><td>管线</td><td style="text-align:right">\$1</td><td style="text-align:center">234</td></tr></tbody></table><h3 id="8-更详细语法说明"><a href="#8-更详细语法说明" class="headerlink" title="8. 更详细语法说明"></a>8. 更详细语法说明</h3><p>想要查看更详细的语法说明，可以参考我们准备的 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown" target="_blank" rel="noopener">Cmd Markdown 简明语法手册</a>，进阶用户可以参考 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-高阶语法手册" target="_blank" rel="noopener">Cmd Markdown 高阶语法手册</a> 了解更多高级功能。</p><p>总而言之，不同于其它 <em>所见即所得</em> 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。<strong>Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。</strong> 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。</p><hr><h2 id="什么是-Cmd-Markdown"><a href="#什么是-Cmd-Markdown" class="headerlink" title="什么是 Cmd Markdown"></a>什么是 Cmd Markdown</h2><p>您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 <strong>编辑/发布/阅读</strong> Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。</p><h3 id="1-实时同步预览"><a href="#1-实时同步预览" class="headerlink" title="1. 实时同步预览"></a>1. 实时同步预览</h3><p>我们将 Cmd Markdown 的主界面一分为二，左边为<strong>编辑区</strong>，右边为<strong>预览区</strong>，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！</p><h3 id="2-编辑工具栏"><a href="#2-编辑工具栏" class="headerlink" title="2. 编辑工具栏"></a>2. 编辑工具栏</h3><p>也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 <strong>编辑区</strong> 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。</p><p><img src="https://www.zybuluo.com/static/img/toolbar-editor.png" alt="tool-editor"></p><h3 id="3-编辑模式"><a href="#3-编辑模式" class="headerlink" title="3. 编辑模式"></a>3. 编辑模式</h3><p>完全心无旁骛的方式编辑文字：点击 <strong>编辑工具栏</strong> 最右侧的拉伸按钮或者按下 <code>Ctrl + M</code>，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！</p><h3 id="4-实时的云端文稿"><a href="#4-实时的云端文稿" class="headerlink" title="4. 实时的云端文稿"></a>4. 实时的云端文稿</h3><p>为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 <strong>编辑工具栏</strong> 的最右侧提示 <code>已保存</code> 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。</p><h3 id="5-离线模式"><a href="#5-离线模式" class="headerlink" title="5. 离线模式"></a>5. 离线模式</h3><p>在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。</p><h3 id="6-管理工具栏"><a href="#6-管理工具栏" class="headerlink" title="6. 管理工具栏"></a>6. 管理工具栏</h3><p>为了便于管理您的文稿，在 <strong>预览区</strong> 的顶部放置了如下所示的 <strong>管理工具栏</strong>：</p><p><img src="https://www.zybuluo.com/static/img/toolbar-manager.jpg" alt="tool-manager"></p><p>通过管理工具栏可以：</p><p><i class="icon-share"></i> 发布：将当前的文稿生成固定链接，在网络上发布，分享<br><i class="icon-file"></i> 新建：开始撰写一篇新的文稿<br><i class="icon-trash"></i> 删除：删除当前的文稿<br><i class="icon-cloud"></i> 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地<br><i class="icon-reorder"></i> 列表：所有新增和过往的文稿都可以在这里查看、操作<br><i class="icon-pencil"></i> 模式：切换 普通/Vim/Emacs 编辑模式</p><h3 id="7-阅读工具栏"><a href="#7-阅读工具栏" class="headerlink" title="7. 阅读工具栏"></a>7. 阅读工具栏</h3><p><img src="https://www.zybuluo.com/static/img/toolbar-reader.jpg" alt="tool-manager"></p><p>通过 <strong>预览区</strong> 右上角的 <strong>阅读工具栏</strong>，可以查看当前文稿的目录并增强阅读体验。</p><p>工具栏上的五个图标依次为：</p><p><i class="icon-list"></i> 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落<br><i class="icon-chevron-sign-left"></i> 视图：互换左边编辑区和右边预览区的位置<br><i class="icon-adjust"></i> 主题：内置了黑白两种模式的主题，试试 <strong>黑色主题</strong>，超炫！<br><i class="icon-desktop"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验<br><i class="icon-fullscreen"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境</p><h3 id="8-阅读模式"><a href="#8-阅读模式" class="headerlink" title="8. 阅读模式"></a>8. 阅读模式</h3><p>在 <strong>阅读工具栏</strong> 点击 <i class="icon-desktop"></i> 或者按下 <code>Ctrl+Alt+M</code> 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。</p><h3 id="9-标签、分类和搜索"><a href="#9-标签、分类和搜索" class="headerlink" title="9. 标签、分类和搜索"></a>9. 标签、分类和搜索</h3><p>在编辑区任意行首位置输入以下格式的文字可以标签当前文档：</p><p>标签： 未分类</p><p>标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：</p><p><img src="https://www.zybuluo.com/static/img/file-list.png" alt="file-list"></p><h3 id="10-文稿发布和分享"><a href="#10-文稿发布和分享" class="headerlink" title="10. 文稿发布和分享"></a>10. 文稿发布和分享</h3><p>在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class="icon-share"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！</p><hr><p>再一次感谢您花费时间阅读这份欢迎稿，点击 <i class="icon-file"></i> (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！</p><p>作者 <a href="http://weibo.com/ghosert" target="_blank" rel="noopener">@ghosert</a><br>2016 年 07月 07日    </p><p>[^LaTeX]: 支持 <strong>LaTeX</strong> 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">MathJax</a> 参考更多使用方法。</p><p>[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，<strong>四十一</strong>种主流编程语言。</p>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
